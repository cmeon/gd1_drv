/*
** Copyright (c) 2002, Scott Lystig Fritchie.  All rights reserved.
** See the file "LICENSE" at the top of the source distribution for
** full license terms.
**
** NOTICE: This file was generated by the tools of the Erlang Driver
**         toolkit.  Do not edit this file by hand unless you know
**         what you're doing!
**
*/

#ifndef __GD1_DRV_H
#define __GD1_DRV_H

#ifdef   DRIVER_USING_PTHREADS
#include <pthread.h>
#endif   /* DRIVER_USING_PTHREADS */

/*
** Driver<->emulator communication codes (xref with top of gd1_drv.hrl)
*/

#define _DEBUG                          0
#define _GDIMAGECREATE                  1
#define _GDIMAGECREATEFROMJPEG          2
#define _GDIMAGECREATEFROMPNG           3
#define _GDIMAGECREATEFROMGD            4
#define _GDIMAGECREATEFROMGD2           5
#define _GDIMAGECREATEFROMGD2PART       6
#define _GDIMAGECREATEFROMXPM           7
#define _GDIMAGECOLORALLOCATE           8
#define _GDIMAGECOLORCLOSEST            9
#define _GDIMAGECOLOREXACT              10
#define _GDIMAGECOLORRESOLVE            11
#define _GDIMAGECOLORSTOTAL             12
#define _GDIMAGEGETINTERLACED           13
#define _GDIMAGEGETTRANSPARENT          14
#define _GDIMAGECOLORDEALLOCATE         15
#define _GDIMAGECOLORTRANSPARENT        16
#define _GDIMAGESETPIXEL                17
#define _GDIMAGELINE                    18
#define _GDIMAGEPOLYGON                 19
#define _GDIMAGEFILLEDPOLYGON           20
#define _GDIMAGERECTANGLE               21
#define _GDIMAGEFILLEDRECTANGLE         22
#define _GDIMAGEARC                     23
#define _GDIMAGEFILLTOBORDER            24
#define _GDIMAGEFILL                    25
#define _GDIMAGESETBRUSH                26
#define _GDIMAGESETTILE                 27
#define _GDIMAGESETSTYLE                28
#define _GDIMAGEGETPIXEL                29
#define _GDIMAGERED                     30
#define _GDIMAGEGREEN                   31
#define _GDIMAGEBLUE                    32
#define _GDIMAGEBOUNDSSAFE              33
#define _GDIMAGESX                      34
#define _GDIMAGESY                      35
#define _GDIMAGEPNG                     36
#define _GDIMAGEPNGPTR                  37
#define _GDIMAGEPNGPTR_QQQ_DELETEME     38
#define _GDIMAGEJPEG                    39
#define _GDIMAGEJPEGPTR                 40
#define _GDIMAGEWBMP                    41
#define _GDIMAGEWBMPPTR                 42
#define _GDIMAGEGD                      43
#define _GDIMAGEGDPTR                   44
#define _GDIMAGEGD2                     45
#define _GDIMAGEGD2PTR                  46
#define _FOPEN                          47
#define _FCLOSE                         48
#define _GDIMAGEPNGFILE                 49
#define _GDIMAGEJPEGFILE                50
#define _GDIMAGEDESTROY                 51
#define _GETFONTPTR                     52
#define _GDIMAGECHAR                    53
#define _GDIMAGECHARUP                  54
#define _GDIMAGESTRING                  55
#define _GDIMAGESTRINGUP                56
#define _GDIMAGECOPY                    57
#define _GDIMAGECOPYRESIZED             58
#define _GDIMAGECOPYMERGE               59
#define _GDIMAGECOPYMERGEGRAY           60
#define _GDIMAGEPALETTECOPY             61
#define _GDIMAGECOMPARE                 62
#define _GDIMAGEINTERLACE               63

/*
** Constants
*/

#ifndef MAX_POLYGON_VERTICES
#define MAX_POLYGON_VERTICES  512    /* Max vertices/polygon */
#endif
#ifndef MAX_STYLE_LENGTH
#define MAX_STYLE_LENGTH  512    /* Max ints for style length */
#endif
#ifndef FONT_TINY
#define FONT_TINY       1    /* gdFontTiny */
#endif
#ifndef FONT_SMALL
#define FONT_SMALL      2    /* gdFontSmall */
#endif
#ifndef FONT_MEDIUMBOLD
#define FONT_MEDIUMBOLD  3    /* gdFontMediumBold */
#endif
#ifndef FONT_LARGE
#define FONT_LARGE      4    /* gdFontLarge */
#endif
#ifndef FONT_GIANT
#define FONT_GIANT      5    /* gdFontGiant */
#endif

#define  MAX_BINVS              24      /* QQQ dumb const! */

#define  VALMAP_INUSE           0x01
#define  VALMAP_DELAYED_CLEANUP 0x02

/*
** descriptor_t = general state for the port
**
*/

struct descriptor {
    ErlDrvPort          port;
    unsigned short      nextxid;        /* Call txn ID for very async calls */
    gdImagePtr          valmap_imageptr[32];
    FILE *              valmap_FILE_P[8];
    gdFontPtr           valmap_fontptr[32];
};

/*
** callstate_t: asychronous call state
**
** TODO: Fill in the struct members of "i" and "o" below.
*/
typedef struct callstate {
    struct callstate    *next;
    int                 cmd;            /* call/command # */
#define XXXKEY  ((void *) 1)
    unsigned int        *key;           /* Not really used */
    void                (*invoke)(void *);
    void                (*free)(void *);
    unsigned short      xid;            /* Only used by as_control()-
                                           initiated funcs */
    /*
    ** Input & output args use a struct simply for convenient
    ** naming & grouping.  There isn't any attempt to get smart about
    ** using a union or anything like that to avoid bloating the size
    ** of these structs with the combined args of a zillion different
    ** functions.  QQQ For future use: look into the use of unions
    ** and/or different flavors of callstate_t to avoid structure bloat.
    */
    struct {
        int             __valmap_imageptr_index;
        int             __valmap_FILE_P_index;
        int             __valmap_fontptr_index;
        unsigned long   __stash[4];
        int             sx;
        int             sy;
        char *          filename;
        int             srcX;
        int             srcY;
        int             h;
        int             w;
        gdImagePtr      im;
        int             r;
        int             g;
        int             b;
        int             color;
        int             x;
        int             y;
        int             x1;
        int             y1;
        int             x2;
        int             y2;
        char *          points;
        int             pointsTotal;
        int             cx;
        int             cy;
        int             s;
        int             e;
        int             border;
        gdImagePtr      brush;
        char *          style;
        int             styleLength;
        int             quality;
        int             fg;
        int             chunkSize;
        int             fmt;
        char *          path;
        char *          fmode;
        FILE *          filep;
        FILE *          outFile;
        int             font_idx;
        gdFontPtr       font;
        int             c;
        unsigned char *  string;
        gdImagePtr      dst;
        gdImagePtr      src;
        int             dstX;
        int             dstY;
        int             destW;
        int             destH;
        int             srcW;
        int             srcH;
        int             pct;
        int             interlace;
    } i;
    struct {
        int             __expect;
        int             __expect_errval;
        gdImagePtr      ret_gdImagePtr; /* XXX 1 */
        int             ret_int; /* XXX 1 */
        void *          ret_void_p; /* XXX 1 */
        FILE *          filep; /* XXX 1 */
        gdFontPtr       ret_gdFontPtr; /* XXX 1 */
        int             status;
        int             size;
    } o;
} callstate_t;

/*
** End of autogenerated code
**  script = ../../edtk/c_h_template.gsl
**  filename = gd1.xml
**  gslgen version = 2.000 Beta 1
**  date = 2003/05/12
**  time = 21:06:37
*/

#endif  /* __GD1_DRV_H */
