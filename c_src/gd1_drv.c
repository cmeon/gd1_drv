/*
** File    : gd1_drv.c
** Summary : An Erlang driver interface for libgd version 1
** 
** NOTICE: This file was generated by the tools of the Erlang Driver
**         toolkit.  Do not edit this file by hand unless you know
**         what you're doing!
** 
** Copyright (c) 2002, Scott Lystig Fritchie.  All rights reserved.
** See the file "LICENSE" at the top of the source distribution for
** full license terms.
*/

/*
** QQQ Before I forget yet again to write this down...
**
** ... the valmap ID assignment has a weakness that should be fixed
** sometime in the future.  The weakness is that reusing the array
** indexes could result in Erlang being able to access a later
** incarnation of a valmap table entry by simply remembering a
** previous valmap {valmap_blah, Integer} and resending it to the
** driver, hoping to get (un)lucky.  
**
** The solution would be to choose a valmap index from a larger, very
** unlikely to repeat set, and use a mapping data structure less naive
** than a dumb array.
**
** QQQ cannot pass references from driver -> Erlang!  Gah!
*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <sys/types.h>
#include <assert.h>
#ifdef   DRIVER_USING_PTHREADS
#include <pthread.h>
#else    /* DRIVER_USING_PTHREADS */
#define  pthread_self()         0
#endif   /* DRIVER_USING_PTHREADS */

/* TODO: Add additional system & local header file #includes */

#include <erl_driver.h>
#include <erl_driver_tk.h>

/* <verbatim place="top_cpp_stuff"> */

#include <stdio.h>
#include <string.h>
#include <errno.h>

#include <gd.h>
#include <my-gd1.h>

/* </verbatim --place="top_cpp_stuff"--> */

/* Last, but not least.... */
#include <gd1_drv.h>


static ErlDrvTermData am_ok;
static ErlDrvTermData am_error;
static ErlDrvTermData am_badarg;
static ErlDrvTermData am_enomem;
static ErlDrvTermData am_unknown;
static ErlDrvTermData am_valmap_imageptr;
static ErlDrvTermData am_valmap_FILE_P;
static ErlDrvTermData am_valmap_fontptr;

static int default_async_calls = 0;

/* This variable may be set only by pipe-main! */
int pipe_driver_p = 0;

/*
** TODO: Define any other Erlang terms this driver may return.
*/

/* Function prototypes */

ErlDrvEntry *driver_init(void *);       /* Do not change name! */
static int _init(void);
static ErlDrvData _start(ErlDrvPort port, char *command);
static void _stop(ErlDrvData drv_data);
static void _output(ErlDrvData drv_data, char *buf, int len);
static int _control(ErlDrvData drv_data, unsigned int command, char *buf, int len, char **rbuf, int rlen);
static void _outputv(ErlDrvData drv_data, ErlIOVec *ev);
static void _ready_async(ErlDrvData drv_data, ErlDrvThreadData thread_data);

void *sys_alloc(size_t);
void *sys_realloc(void *, size_t);
void sys_free(void *);

static void invoke__gdImageCreate(void *data);
static void invoke__gdImageCreateFromJpeg(void *data);
static void invoke__gdImageCreateFromPng(void *data);
static void invoke__gdImageCreateFromGd(void *data);
static void invoke__gdImageCreateFromGd2(void *data);
static void invoke__gdImageCreateFromGd2Part(void *data);
static void invoke__gdImageCreateFromXpm(void *data);
static void invoke__gdImageColorAllocate(void *data);
static void invoke__gdImageColorClosest(void *data);
static void invoke__gdImageColorExact(void *data);
static void invoke__gdImageColorResolve(void *data);
static void invoke__gdImageColorsTotal(void *data);
static void invoke__gdImageGetInterlaced(void *data);
static void invoke__gdImageGetTransparent(void *data);
static void invoke__gdImageColorDeallocate(void *data);
static void invoke__gdImageColorTransparent(void *data);
static void invoke__gdImageSetPixel(void *data);
static void invoke__gdImageLine(void *data);
static void invoke__gdImagePolygon(void *data);
static void invoke__gdImageFilledPolygon(void *data);
static void invoke__gdImageRectangle(void *data);
static void invoke__gdImageFilledRectangle(void *data);
static void invoke__gdImageArc(void *data);
static void invoke__gdImageFillToBorder(void *data);
static void invoke__gdImageFill(void *data);
static void invoke__gdImageSetBrush(void *data);
static void invoke__gdImageSetTile(void *data);
static void invoke__gdImageSetStyle(void *data);
static void invoke__gdImageGetPixel(void *data);
static void invoke__gdImageRed(void *data);
static void invoke__gdImageGreen(void *data);
static void invoke__gdImageBlue(void *data);
static void invoke__gdImageBoundsSafe(void *data);
static void invoke__gdImageSX(void *data);
static void invoke__gdImageSY(void *data);
static void invoke__gdImagePng(void *data);
static void invoke__gdImagePngPtr(void *data);
static void invoke__gdImagePngPtr_QQQ_deleteme(void *data);
static void invoke__gdImageJpeg(void *data);
static void invoke__gdImageJpegPtr(void *data);
static void invoke__gdImageWBMP(void *data);
static void invoke__gdImageWBMPPtr(void *data);
static void invoke__gdImageGd(void *data);
static void invoke__gdImageGdPtr(void *data);
static void invoke__gdImageGd2(void *data);
static void invoke__gdImageGd2Ptr(void *data);
static void invoke__fopen(void *data);
static void invoke__fclose(void *data);
static void invoke__gdImagePngFILE(void *data);
static void invoke__gdImageJpegFILE(void *data);
static void invoke__gdImageDestroy(void *data);
static void invoke__getFontPtr(void *data);
static void invoke__gdImageChar(void *data);
static void invoke__gdImageCharUp(void *data);
static void invoke__gdImageString(void *data);
static void invoke__gdImageStringUp(void *data);
static void invoke__gdImageCopy(void *data);
static void invoke__gdImageCopyResized(void *data);
static void invoke__gdImageCopyMerge(void *data);
static void invoke__gdImageCopyMergeGray(void *data);
static void invoke__gdImagePaletteCopy(void *data);
static void invoke__gdImageCompare(void *data);
static void invoke__gdImageInterlace(void *data);

static int reply_xtra_void_p_and_size(descriptor_t *, callstate_t *);

static int find_unused_imageptr_index(descriptor_t *, unsigned long *);
static void cleanup_valmap_imageptr_index(descriptor_t *, int, int);
static void cleanup_valmap_imageptr_all(descriptor_t *, int);
static int find_unused_FILE_P_index(descriptor_t *, unsigned long *);
static void cleanup_valmap_FILE_P_index(descriptor_t *, int, int);
static void cleanup_valmap_FILE_P_all(descriptor_t *, int);
static int find_unused_fontptr_index(descriptor_t *, unsigned long *);
static void cleanup_valmap_fontptr_index(descriptor_t *, int, int);
static void cleanup_valmap_fontptr_all(descriptor_t *, int);

static int reply_ok(descriptor_t *desc);
static int reply_ok_num(descriptor_t *desc, unsigned long num);
static int reply_ok_binary(descriptor_t *desc, char *p, int, int);
static int reply_ok_valmap(descriptor_t *, ErlDrvTermData, unsigned long);
static int reply_error(descriptor_t *desc, int errnum);
static int reply_error_atom(descriptor_t *, ErlDrvTermData);
#if     0
static int reply_tag_ok(descriptor_t *desc, unsigned short tag);
static int reply_tag_error(descriptor_t *desc, unsigned short tag, int errnum);
#endif  /* 0 */

static ErlDrvEntry _driver_entry = {
    _init,                      /* init */
    _start,                     /* start */
    _stop,                      /* stop */
    _output,                    /* output */
    NULL,                       /* ready_input */
    NULL,                       /* ready_output */
    "gd1_drv",                  /* driver_name */
    NULL,                       /* finish */
    NULL,                       /* handle */
    _control,                   /* control */
    NULL,                       /* timeout */
    _outputv,                   /* outputv */
    _ready_async,               /* ready_async */
    NULL,                       /* flush */
    NULL                        /* call */
};

/*
** All dynamically-loadable driver libraries must contain a driver_init().
*/

ErlDrvEntry *
driver_init(void *handle)
{
    edtk_debug_flag = 0;
    _driver_entry.handle = handle;
    return &_driver_entry;
}

static int
_init(void)
{
    am_ok = driver_mk_atom("ok");
    am_error = driver_mk_atom("error");
    am_badarg = driver_mk_atom("badarg");
    am_enomem = driver_mk_atom("enomem");
    am_unknown = driver_mk_atom("unknown");
    am_valmap_imageptr = driver_mk_atom("valmap_imageptr");
    am_valmap_FILE_P = driver_mk_atom("valmap_FILE_P");
    am_valmap_fontptr = driver_mk_atom("valmap_fontptr");

    /* TODO: Take care of other first-time initialization tasks */

    return 0;
}

static ErlDrvData
_start(ErlDrvPort port, char *args)
{
    descriptor_t        *desc;
    int                 i = 0;

    i = i;
    edtk_debug("%s: starting, port = %ld, args = 0x%lx, %s", __FUNCTION__,
               port, (unsigned long) args, args);

    if ((desc = (descriptor_t *) sys_alloc(sizeof(descriptor_t))) == NULL) {
        return ERL_DRV_ERROR_GENERAL;
    }
    memset(desc, 0, sizeof(descriptor_t));
    desc->port = port;
    desc->nextxid = 1;
    for (i = 0; i < 32; i++) {
        desc->valmap_imageptr[i] = NULL;
    }
    for (i = 0; i < 8; i++) {
        desc->valmap_FILE_P[i] = NULL;
    }
    for (i = 0; i < 32; i++) {
        desc->valmap_fontptr[i] = NULL;
    }
    /* TODO: Finish initializing descriptor members */

    /* TODO: Take care of other port initialization tasks */

    return (ErlDrvData) desc;
}

static void
_stop(ErlDrvData drv_data)
{
    descriptor_t        *desc = (descriptor_t *) drv_data;
    int                 i = 0;
    ErlDrvPort          port;
    int                 still_in_use = 0;

    i = i;
    if (desc == NULL) {
        edtk_debug("%s: drv_data == NULL", __FUNCTION__);
        return;
    }
    edtk_debug("%s: port = %ld", __FUNCTION__, desc->port);

    for (i = 0; i < 32; i++) {
        if (desc->valmap_imageptr[i] != NULL) {
            cleanup_valmap_imageptr_index(desc, i, 1);
        }
    }
    for (i = 0; i < 8; i++) {
        if (desc->valmap_FILE_P[i] != NULL) {
            cleanup_valmap_FILE_P_index(desc, i, 1);
        }
    }
    for (i = 0; i < 32; i++) {
        if (desc->valmap_fontptr[i] != NULL) {
            cleanup_valmap_fontptr_index(desc, i, 1);
        }
    }

    if (! still_in_use) {
        port = desc->port;
        sys_free(desc);    
        edtk_debug("%s: port = %ld finished", __FUNCTION__, port);
    } else {
        /*
        ** QQQ Oi, this is a sticky problem.  This port is being shut
        ** down, but we've still got some valmaps in use.  We have no
        ** way to tell the VM that we cannot be shut down safely right
        ** now, so what in the heck do we do?  It seems to me that we
        ** have two choices:
        **   1. Block the entire VM until all valmaps are idle, then
        **      clean them up and then return.
        **   2. Create a new thread that will take care of monitoring
        **      the valmaps & doing their final cleanup.  This stop
        **      function, executing in the main thread, can return
        **      to the VM right away.
        ** For the sake of simplicity, I'm going to implement #1
        ** for now.  This will get more complicated once EDTK supports
        ** private worker threads, so we won't bother getting fancy
        ** for now.
        */
        edtk_debug("%s: port = %ld has %d valmaps still in use!", __FUNCTION__, desc->port, still_in_use);

        /*
        ** QQQ Perhaps an alternative would be to create another
        ** thread to (slowly) spin-wait on still-in-use valmap, and
        ** when it's idle, have that thread free "desc" then exit?
        */
        sleep(1);  /* QQQ Ouch, this is brute force, but hey, it's simple */
        _stop(drv_data);                /* Hope we don't run out of stack */
    }
}

static void
_output(ErlDrvData drv_data, char *buf, int len)
{
    /*
    ** Nobody should be calling this function because we've
    ** defined the "outputv" driver method, which BEAM will always
    ** used if it's available.  I just put a debug statement in
    ** here so that I might actually notice if the impossible ever
    ** happens....
    */
    edtk_debug("%s: XXX someone tried to call us, silly", __FUNCTION__);
}

static int
_control(ErlDrvData drv_data, unsigned int command,
                  char *buf, int len, char **rbuf, int rlen)
{
    char        *ret = *rbuf;
    int         retlen;

    /*
    ** Nobody should be calling this function either.
    */
    ret[0] = 1;
    retlen = 1;
    edtk_debug("%s: XXX someone tried to call us, silly", __FUNCTION__);
    return retlen;
}

static void
_outputv(ErlDrvData drv_data, ErlIOVec *ev)
{
    descriptor_t        *desc = (descriptor_t *) drv_data;
    unsigned char       cmd;
    int                 p = 0, q = 1;
    callstate_t         *c = NULL;
    int                 do_async_call = default_async_calls;
    unsigned long       binlen;
    int                 index;
    void                *tmp = NULL;

    binlen = binlen;
    index = index;
    tmp = tmp;
    if (desc == NULL || ev == NULL || ev->size < 1) {
        edtk_debug("%s: bad arg(s)", __FUNCTION__);
        return;
    }
    if (! EV_GET_CHAR(ev, &cmd, &p, &q)) {
        edtk_debug("%s: empty command", __FUNCTION__);
        reply_error(desc, EINVAL);
    }
    if ((c = sys_alloc(sizeof(callstate_t))) == NULL) {
        reply_error(desc, ENOMEM);
        return;
    }
    c->cmd = cmd;
    c->key = NULL;
    c->free = sys_free;
    c->xid = 0;         /* QQQ unused right now */
    c->o.__expect = 1;  /* Default is that expectation is always met */

    edtk_debug("%s: my threadid = %lx, cmd = %d", __FUNCTION__, pthread_self(), cmd);
    switch (cmd) {
    case _DEBUG:
        EV_GET_UINT32(ev, &edtk_debug_flag, &p, &q);
        reply_ok_num(desc, edtk_debug_flag);    /* Immediate reply */
        sys_free(c);
        c = NULL;
        break;
    case _GDIMAGECREATE:
        c->invoke = invoke__gdImageCreate;
        EV_GET_UINT32(ev, &c->i.sx, &p, &q);
        EV_GET_UINT32(ev, &c->i.sy, &p, &q);
        break;
    case _GDIMAGECREATEFROMJPEG:
        c->invoke = invoke__gdImageCreateFromJpeg;
        EV_GET_UINT32(ev, &binlen, &p, &q);
        c->i.filename = (char *) EV_GETPOS(ev, p, q);
        if (edtk_ev_forward_N(ev, binlen, &p, &q, 1) < 0) {
            goto error;
        }
        break;
    case _GDIMAGECREATEFROMPNG:
        c->invoke = invoke__gdImageCreateFromPng;
        EV_GET_UINT32(ev, &binlen, &p, &q);
        c->i.filename = (char *) EV_GETPOS(ev, p, q);
        if (edtk_ev_forward_N(ev, binlen, &p, &q, 1) < 0) {
            goto error;
        }
        break;
    case _GDIMAGECREATEFROMGD:
        c->invoke = invoke__gdImageCreateFromGd;
        EV_GET_UINT32(ev, &binlen, &p, &q);
        c->i.filename = (char *) EV_GETPOS(ev, p, q);
        if (edtk_ev_forward_N(ev, binlen, &p, &q, 1) < 0) {
            goto error;
        }
        break;
    case _GDIMAGECREATEFROMGD2:
        c->invoke = invoke__gdImageCreateFromGd2;
        EV_GET_UINT32(ev, &binlen, &p, &q);
        c->i.filename = (char *) EV_GETPOS(ev, p, q);
        if (edtk_ev_forward_N(ev, binlen, &p, &q, 1) < 0) {
            goto error;
        }
        break;
    case _GDIMAGECREATEFROMGD2PART:
        c->invoke = invoke__gdImageCreateFromGd2Part;
        EV_GET_UINT32(ev, &binlen, &p, &q);
        c->i.filename = (char *) EV_GETPOS(ev, p, q);
        if (edtk_ev_forward_N(ev, binlen, &p, &q, 1) < 0) {
            goto error;
        }
        EV_GET_UINT32(ev, &c->i.srcX, &p, &q);
        EV_GET_UINT32(ev, &c->i.srcY, &p, &q);
        EV_GET_UINT32(ev, &c->i.h, &p, &q);
        EV_GET_UINT32(ev, &c->i.w, &p, &q);
        break;
    case _GDIMAGECREATEFROMXPM:
        c->invoke = invoke__gdImageCreateFromXpm;
        EV_GET_UINT32(ev, &binlen, &p, &q);
        c->i.filename = (char *) EV_GETPOS(ev, p, q);
        if (edtk_ev_forward_N(ev, binlen, &p, &q, 1) < 0) {
            goto error;
        }
        break;
    case _GDIMAGECOLORALLOCATE:
        c->invoke = invoke__gdImageColorAllocate;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &c->i.r, &p, &q);
        EV_GET_UINT32(ev, &c->i.g, &p, &q);
        EV_GET_UINT32(ev, &c->i.b, &p, &q);
        break;
    case _GDIMAGECOLORCLOSEST:
        c->invoke = invoke__gdImageColorClosest;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &c->i.r, &p, &q);
        EV_GET_UINT32(ev, &c->i.g, &p, &q);
        EV_GET_UINT32(ev, &c->i.b, &p, &q);
        break;
    case _GDIMAGECOLOREXACT:
        c->invoke = invoke__gdImageColorExact;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &c->i.r, &p, &q);
        EV_GET_UINT32(ev, &c->i.g, &p, &q);
        EV_GET_UINT32(ev, &c->i.b, &p, &q);
        break;
    case _GDIMAGECOLORRESOLVE:
        c->invoke = invoke__gdImageColorResolve;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &c->i.r, &p, &q);
        EV_GET_UINT32(ev, &c->i.g, &p, &q);
        EV_GET_UINT32(ev, &c->i.b, &p, &q);
        break;
    case _GDIMAGECOLORSTOTAL:
        c->invoke = invoke__gdImageColorsTotal;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        break;
    case _GDIMAGEGETINTERLACED:
        c->invoke = invoke__gdImageGetInterlaced;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        break;
    case _GDIMAGEGETTRANSPARENT:
        c->invoke = invoke__gdImageGetTransparent;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        break;
    case _GDIMAGECOLORDEALLOCATE:
        c->invoke = invoke__gdImageColorDeallocate;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &c->i.color, &p, &q);
        break;
    case _GDIMAGECOLORTRANSPARENT:
        c->invoke = invoke__gdImageColorTransparent;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &c->i.color, &p, &q);
        break;
    case _GDIMAGESETPIXEL:
        c->invoke = invoke__gdImageSetPixel;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &c->i.x, &p, &q);
        EV_GET_UINT32(ev, &c->i.y, &p, &q);
        EV_GET_UINT32(ev, &c->i.color, &p, &q);
        break;
    case _GDIMAGELINE:
        c->invoke = invoke__gdImageLine;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &c->i.x1, &p, &q);
        EV_GET_UINT32(ev, &c->i.y1, &p, &q);
        EV_GET_UINT32(ev, &c->i.x2, &p, &q);
        EV_GET_UINT32(ev, &c->i.y2, &p, &q);
        EV_GET_UINT32(ev, &c->i.color, &p, &q);
        break;
    case _GDIMAGEPOLYGON:
        c->invoke = invoke__gdImagePolygon;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &binlen, &p, &q);
        c->i.__stash[0] = binlen;
        c->i.points = (char *) EV_GETPOS(ev, p, q);
        if (edtk_ev_forward_N(ev, binlen, &p, &q, 1) < 0) {
            goto error;
        }
        EV_GET_UINT32(ev, &c->i.pointsTotal, &p, &q);
        EV_GET_UINT32(ev, &c->i.color, &p, &q);
        /* <hack place="post-deserialize" type="verbatim"> */

        if (c->i.pointsTotal != (c->i.__stash[0] / (sizeof(long) * 2))) {
                goto error;
        }
 
        /* </hack --place="post-deserialize" type="verbatim"--> */
        break;
    case _GDIMAGEFILLEDPOLYGON:
        c->invoke = invoke__gdImageFilledPolygon;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &binlen, &p, &q);
        c->i.__stash[0] = binlen;
        c->i.points = (char *) EV_GETPOS(ev, p, q);
        if (edtk_ev_forward_N(ev, binlen, &p, &q, 1) < 0) {
            goto error;
        }
        EV_GET_UINT32(ev, &c->i.pointsTotal, &p, &q);
        EV_GET_UINT32(ev, &c->i.color, &p, &q);
        break;
    case _GDIMAGERECTANGLE:
        c->invoke = invoke__gdImageRectangle;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &c->i.x1, &p, &q);
        EV_GET_UINT32(ev, &c->i.y1, &p, &q);
        EV_GET_UINT32(ev, &c->i.x2, &p, &q);
        EV_GET_UINT32(ev, &c->i.y2, &p, &q);
        EV_GET_UINT32(ev, &c->i.color, &p, &q);
        break;
    case _GDIMAGEFILLEDRECTANGLE:
        c->invoke = invoke__gdImageFilledRectangle;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &c->i.x1, &p, &q);
        EV_GET_UINT32(ev, &c->i.y1, &p, &q);
        EV_GET_UINT32(ev, &c->i.x2, &p, &q);
        EV_GET_UINT32(ev, &c->i.y2, &p, &q);
        EV_GET_UINT32(ev, &c->i.color, &p, &q);
        break;
    case _GDIMAGEARC:
        c->invoke = invoke__gdImageArc;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &c->i.cx, &p, &q);
        EV_GET_UINT32(ev, &c->i.cy, &p, &q);
        EV_GET_UINT32(ev, &c->i.w, &p, &q);
        EV_GET_UINT32(ev, &c->i.h, &p, &q);
        EV_GET_UINT32(ev, &c->i.s, &p, &q);
        EV_GET_UINT32(ev, &c->i.e, &p, &q);
        EV_GET_UINT32(ev, &c->i.color, &p, &q);
        break;
    case _GDIMAGEFILLTOBORDER:
        c->invoke = invoke__gdImageFillToBorder;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &c->i.x, &p, &q);
        EV_GET_UINT32(ev, &c->i.y, &p, &q);
        EV_GET_UINT32(ev, &c->i.border, &p, &q);
        EV_GET_UINT32(ev, &c->i.color, &p, &q);
        break;
    case _GDIMAGEFILL:
        c->invoke = invoke__gdImageFill;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &c->i.x, &p, &q);
        EV_GET_UINT32(ev, &c->i.y, &p, &q);
        EV_GET_UINT32(ev, &c->i.color, &p, &q);
        break;
    case _GDIMAGESETBRUSH:
        c->invoke = invoke__gdImageSetBrush;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.brush = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.brush = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        break;
    case _GDIMAGESETTILE:
        c->invoke = invoke__gdImageSetTile;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.brush = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.brush = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        break;
    case _GDIMAGESETSTYLE:
        c->invoke = invoke__gdImageSetStyle;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &binlen, &p, &q);
        c->i.__stash[0] = binlen;
        c->i.style = (char *) EV_GETPOS(ev, p, q);
        if (edtk_ev_forward_N(ev, binlen, &p, &q, 1) < 0) {
            goto error;
        }
        EV_GET_UINT32(ev, &c->i.styleLength, &p, &q);
        break;
    case _GDIMAGEGETPIXEL:
        c->invoke = invoke__gdImageGetPixel;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &c->i.x, &p, &q);
        EV_GET_UINT32(ev, &c->i.y, &p, &q);
        break;
    case _GDIMAGERED:
        c->invoke = invoke__gdImageRed;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &c->i.color, &p, &q);
        break;
    case _GDIMAGEGREEN:
        c->invoke = invoke__gdImageGreen;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &c->i.color, &p, &q);
        break;
    case _GDIMAGEBLUE:
        c->invoke = invoke__gdImageBlue;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &c->i.color, &p, &q);
        break;
    case _GDIMAGEBOUNDSSAFE:
        c->invoke = invoke__gdImageBoundsSafe;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &c->i.x, &p, &q);
        EV_GET_UINT32(ev, &c->i.y, &p, &q);
        break;
    case _GDIMAGESX:
        c->invoke = invoke__gdImageSX;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        break;
    case _GDIMAGESY:
        c->invoke = invoke__gdImageSY;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        break;
    case _GDIMAGEPNG:
        c->invoke = invoke__gdImagePng;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &binlen, &p, &q);
        c->i.filename = (char *) EV_GETPOS(ev, p, q);
        if (edtk_ev_forward_N(ev, binlen, &p, &q, 1) < 0) {
            goto error;
        }
        break;
    case _GDIMAGEPNGPTR:
        c->invoke = invoke__gdImagePngPtr;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        break;
    case _GDIMAGEPNGPTR_QQQ_DELETEME:
        c->invoke = invoke__gdImagePngPtr_QQQ_deleteme;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        break;
    case _GDIMAGEJPEG:
        c->invoke = invoke__gdImageJpeg;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &binlen, &p, &q);
        c->i.filename = (char *) EV_GETPOS(ev, p, q);
        if (edtk_ev_forward_N(ev, binlen, &p, &q, 1) < 0) {
            goto error;
        }
        EV_GET_UINT32(ev, &c->i.quality, &p, &q);
        break;
    case _GDIMAGEJPEGPTR:
        c->invoke = invoke__gdImageJpegPtr;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &c->i.quality, &p, &q);
        break;
    case _GDIMAGEWBMP:
        c->invoke = invoke__gdImageWBMP;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &c->i.fg, &p, &q);
        EV_GET_UINT32(ev, &binlen, &p, &q);
        c->i.filename = (char *) EV_GETPOS(ev, p, q);
        if (edtk_ev_forward_N(ev, binlen, &p, &q, 1) < 0) {
            goto error;
        }
        break;
    case _GDIMAGEWBMPPTR:
        c->invoke = invoke__gdImageWBMPPtr;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &c->i.fg, &p, &q);
        break;
    case _GDIMAGEGD:
        c->invoke = invoke__gdImageGd;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &binlen, &p, &q);
        c->i.filename = (char *) EV_GETPOS(ev, p, q);
        if (edtk_ev_forward_N(ev, binlen, &p, &q, 1) < 0) {
            goto error;
        }
        break;
    case _GDIMAGEGDPTR:
        c->invoke = invoke__gdImageGdPtr;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        break;
    case _GDIMAGEGD2:
        c->invoke = invoke__gdImageGd2;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &binlen, &p, &q);
        c->i.filename = (char *) EV_GETPOS(ev, p, q);
        if (edtk_ev_forward_N(ev, binlen, &p, &q, 1) < 0) {
            goto error;
        }
        EV_GET_UINT32(ev, &c->i.chunkSize, &p, &q);
        EV_GET_UINT32(ev, &c->i.fmt, &p, &q);
        break;
    case _GDIMAGEGD2PTR:
        c->invoke = invoke__gdImageGd2Ptr;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &c->i.chunkSize, &p, &q);
        EV_GET_UINT32(ev, &c->i.fmt, &p, &q);
        break;
    case _FOPEN:
        c->invoke = invoke__fopen;
        EV_GET_UINT32(ev, &binlen, &p, &q);
        c->i.path = (char *) EV_GETPOS(ev, p, q);
        if (edtk_ev_forward_N(ev, binlen, &p, &q, 1) < 0) {
            goto error;
        }
        EV_GET_UINT32(ev, &binlen, &p, &q);
        c->i.fmode = (char *) EV_GETPOS(ev, p, q);
        if (edtk_ev_forward_N(ev, binlen, &p, &q, 1) < 0) {
            goto error;
        }
        break;
    case _FCLOSE:
        c->invoke = invoke__fclose;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap FILE_P index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.filep = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_FILE_P_index = -1;
        } else if (desc->valmap_FILE_P[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap FILE_P index %d = 0x%lx", __FUNCTION__, index, desc->valmap_FILE_P[index]);
            c->i.filep = desc->valmap_FILE_P[index];
            c->i.__valmap_FILE_P_index = index;
        }
        break;
    case _GDIMAGEPNGFILE:
        c->invoke = invoke__gdImagePngFILE;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap FILE_P index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.outFile = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_FILE_P_index = -1;
        } else if (desc->valmap_FILE_P[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap FILE_P index %d = 0x%lx", __FUNCTION__, index, desc->valmap_FILE_P[index]);
            c->i.outFile = desc->valmap_FILE_P[index];
            c->i.__valmap_FILE_P_index = index;
        }
        break;
    case _GDIMAGEJPEGFILE:
        c->invoke = invoke__gdImageJpegFILE;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap FILE_P index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.outFile = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_FILE_P_index = -1;
        } else if (desc->valmap_FILE_P[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap FILE_P index %d = 0x%lx", __FUNCTION__, index, desc->valmap_FILE_P[index]);
            c->i.outFile = desc->valmap_FILE_P[index];
            c->i.__valmap_FILE_P_index = index;
        }
        EV_GET_UINT32(ev, &c->i.quality, &p, &q);
        break;
    case _GDIMAGEDESTROY:
        c->invoke = invoke__gdImageDestroy;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        break;
    case _GETFONTPTR:
        c->invoke = invoke__getFontPtr;
        EV_GET_UINT32(ev, &c->i.font_idx, &p, &q);
        break;
    case _GDIMAGECHAR:
        c->invoke = invoke__gdImageChar;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap fontptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.font = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_fontptr_index = -1;
        } else if (desc->valmap_fontptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap fontptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_fontptr[index]);
            c->i.font = desc->valmap_fontptr[index];
            c->i.__valmap_fontptr_index = index;
        }
        EV_GET_UINT32(ev, &c->i.x, &p, &q);
        EV_GET_UINT32(ev, &c->i.y, &p, &q);
        EV_GET_UINT32(ev, &c->i.c, &p, &q);
        EV_GET_UINT32(ev, &c->i.color, &p, &q);
        break;
    case _GDIMAGECHARUP:
        c->invoke = invoke__gdImageCharUp;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap fontptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.font = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_fontptr_index = -1;
        } else if (desc->valmap_fontptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap fontptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_fontptr[index]);
            c->i.font = desc->valmap_fontptr[index];
            c->i.__valmap_fontptr_index = index;
        }
        EV_GET_UINT32(ev, &c->i.x, &p, &q);
        EV_GET_UINT32(ev, &c->i.y, &p, &q);
        EV_GET_UINT32(ev, &c->i.c, &p, &q);
        EV_GET_UINT32(ev, &c->i.color, &p, &q);
        break;
    case _GDIMAGESTRING:
        c->invoke = invoke__gdImageString;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap fontptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.font = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_fontptr_index = -1;
        } else if (desc->valmap_fontptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap fontptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_fontptr[index]);
            c->i.font = desc->valmap_fontptr[index];
            c->i.__valmap_fontptr_index = index;
        }
        EV_GET_UINT32(ev, &c->i.x, &p, &q);
        EV_GET_UINT32(ev, &c->i.y, &p, &q);
        EV_GET_UINT32(ev, &binlen, &p, &q);
        c->i.string = (unsigned char *) EV_GETPOS(ev, p, q);
        if (edtk_ev_forward_N(ev, binlen, &p, &q, 1) < 0) {
            goto error;
        }
        EV_GET_UINT32(ev, &c->i.color, &p, &q);
        break;
    case _GDIMAGESTRINGUP:
        c->invoke = invoke__gdImageStringUp;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.im = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.im = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap fontptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.font = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_fontptr_index = -1;
        } else if (desc->valmap_fontptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap fontptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_fontptr[index]);
            c->i.font = desc->valmap_fontptr[index];
            c->i.__valmap_fontptr_index = index;
        }
        EV_GET_UINT32(ev, &c->i.x, &p, &q);
        EV_GET_UINT32(ev, &c->i.y, &p, &q);
        EV_GET_UINT32(ev, &binlen, &p, &q);
        c->i.string = (unsigned char *) EV_GETPOS(ev, p, q);
        if (edtk_ev_forward_N(ev, binlen, &p, &q, 1) < 0) {
            goto error;
        }
        EV_GET_UINT32(ev, &c->i.color, &p, &q);
        break;
    case _GDIMAGECOPY:
        c->invoke = invoke__gdImageCopy;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.dst = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.dst = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.src = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.src = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &c->i.dstX, &p, &q);
        EV_GET_UINT32(ev, &c->i.dstY, &p, &q);
        EV_GET_UINT32(ev, &c->i.srcX, &p, &q);
        EV_GET_UINT32(ev, &c->i.srcY, &p, &q);
        EV_GET_UINT32(ev, &c->i.w, &p, &q);
        EV_GET_UINT32(ev, &c->i.h, &p, &q);
        break;
    case _GDIMAGECOPYRESIZED:
        c->invoke = invoke__gdImageCopyResized;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.dst = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.dst = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.src = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.src = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &c->i.dstX, &p, &q);
        EV_GET_UINT32(ev, &c->i.dstY, &p, &q);
        EV_GET_UINT32(ev, &c->i.srcX, &p, &q);
        EV_GET_UINT32(ev, &c->i.srcY, &p, &q);
        EV_GET_UINT32(ev, &c->i.destW, &p, &q);
        EV_GET_UINT32(ev, &c->i.destH, &p, &q);
        EV_GET_UINT32(ev, &c->i.srcW, &p, &q);
        EV_GET_UINT32(ev, &c->i.srcH, &p, &q);
        break;
    case _GDIMAGECOPYMERGE:
        c->invoke = invoke__gdImageCopyMerge;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.dst = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.dst = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.src = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.src = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &c->i.dstX, &p, &q);
        EV_GET_UINT32(ev, &c->i.dstY, &p, &q);
        EV_GET_UINT32(ev, &c->i.srcX, &p, &q);
        EV_GET_UINT32(ev, &c->i.srcY, &p, &q);
        EV_GET_UINT32(ev, &c->i.w, &p, &q);
        EV_GET_UINT32(ev, &c->i.h, &p, &q);
        EV_GET_UINT32(ev, &c->i.pct, &p, &q);
        break;
    case _GDIMAGECOPYMERGEGRAY:
        c->invoke = invoke__gdImageCopyMergeGray;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.dst = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.dst = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.src = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.src = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &c->i.dstX, &p, &q);
        EV_GET_UINT32(ev, &c->i.dstY, &p, &q);
        EV_GET_UINT32(ev, &c->i.srcX, &p, &q);
        EV_GET_UINT32(ev, &c->i.srcY, &p, &q);
        EV_GET_UINT32(ev, &c->i.w, &p, &q);
        EV_GET_UINT32(ev, &c->i.h, &p, &q);
        EV_GET_UINT32(ev, &c->i.pct, &p, &q);
        break;
    case _GDIMAGEPALETTECOPY:
        c->invoke = invoke__gdImagePaletteCopy;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.dst = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.dst = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.src = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.src = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        break;
    case _GDIMAGECOMPARE:
        c->invoke = invoke__gdImageCompare;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.dst = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.dst = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.src = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.src = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        break;
    case _GDIMAGEINTERLACE:
        c->invoke = invoke__gdImageInterlace;
        EV_GET_UINT32(ev, &index, &p, &q);
        if (index == -1 && 0 == 1) {
            edtk_debug("%s: valmap imageptr index %d = default value 0x%lx", __FUNCTION__, index, NULL);
            c->i.dst = NULL;
            /* QQQ Will indiscriminate use of negative index cause trouble?? */
            c->i.__valmap_imageptr_index = -1;
        } else if (desc->valmap_imageptr[index] == NULL) {
            goto error;
        } else {
            edtk_debug("%s: valmap imageptr index %d = 0x%lx", __FUNCTION__, index, desc->valmap_imageptr[index]);
            c->i.dst = desc->valmap_imageptr[index];
            c->i.__valmap_imageptr_index = index;
        }
        EV_GET_UINT32(ev, &c->i.interlace, &p, &q);
        break;
     default:
        edtk_debug("%s: invalid command %d", __FUNCTION__, cmd);
        goto error;
        break;  
    }
    if (c != NULL) {
        if (do_async_call) {
            driver_async(desc->port, c->key, c->invoke, c, c->free);
        } else {
            /*
            ** Execute the bottom half right away, then send the result.
            */
            (*(c->invoke))((void *) c);
            _ready_async((ErlDrvData) desc, (ErlDrvThreadData) c);
            /* 
            ** c is already freed for us by _ready_async()
            */
        }
    }
    return;

  error:
    if (c != NULL) {
        sys_free(c);
    }
    reply_error_atom(desc, am_badarg);
}

static void
_ready_async(ErlDrvData drv_data, ErlDrvThreadData thread_data)
{
    descriptor_t        *desc = (descriptor_t *) drv_data;
    callstate_t *c = (callstate_t *) thread_data;
    int                 bytes, offset, i;
    char                *p = NULL;
    unsigned long       index = 0;

    p = p;
    bytes = bytes;
    offset = offset;
    i = i;
    index = index;
    edtk_debug("%s: cmd = %d", __FUNCTION__, c->cmd);
    if (c == NULL) {
        edtk_debug("%s: c == NULL", __FUNCTION__);
        return;
    }
    switch (c->cmd) {
    case _GDIMAGECREATE:
        if (! c->o.__expect) {
            reply_error(desc, c->o.__expect_errval);
            break;
        }
        if (find_unused_imageptr_index(desc, &index) < 0) {
            reply_error(desc, ENOMEM);  /* QQQ Better error?? */
        } else {
            desc->valmap_imageptr[index] = c->o.ret_gdImagePtr;
            reply_ok_valmap(desc, am_valmap_imageptr, index);
        }
        break;
    case _GDIMAGECREATEFROMJPEG:
        if (! c->o.__expect) {
            reply_error(desc, c->o.__expect_errval);
            break;
        }
        if (find_unused_imageptr_index(desc, &index) < 0) {
            reply_error(desc, ENOMEM);  /* QQQ Better error?? */
        } else {
            desc->valmap_imageptr[index] = c->o.ret_gdImagePtr;
            reply_ok_valmap(desc, am_valmap_imageptr, index);
        }
        break;
    case _GDIMAGECREATEFROMPNG:
        if (! c->o.__expect) {
            reply_error(desc, c->o.__expect_errval);
            break;
        }
        if (find_unused_imageptr_index(desc, &index) < 0) {
            reply_error(desc, ENOMEM);  /* QQQ Better error?? */
        } else {
            desc->valmap_imageptr[index] = c->o.ret_gdImagePtr;
            reply_ok_valmap(desc, am_valmap_imageptr, index);
        }
        break;
    case _GDIMAGECREATEFROMGD:
        if (! c->o.__expect) {
            reply_error(desc, c->o.__expect_errval);
            break;
        }
        if (find_unused_imageptr_index(desc, &index) < 0) {
            reply_error(desc, ENOMEM);  /* QQQ Better error?? */
        } else {
            desc->valmap_imageptr[index] = c->o.ret_gdImagePtr;
            reply_ok_valmap(desc, am_valmap_imageptr, index);
        }
        break;
    case _GDIMAGECREATEFROMGD2:
        if (! c->o.__expect) {
            reply_error(desc, c->o.__expect_errval);
            break;
        }
        if (find_unused_imageptr_index(desc, &index) < 0) {
            reply_error(desc, ENOMEM);  /* QQQ Better error?? */
        } else {
            desc->valmap_imageptr[index] = c->o.ret_gdImagePtr;
            reply_ok_valmap(desc, am_valmap_imageptr, index);
        }
        break;
    case _GDIMAGECREATEFROMGD2PART:
        if (! c->o.__expect) {
            reply_error(desc, c->o.__expect_errval);
            break;
        }
        if (find_unused_imageptr_index(desc, &index) < 0) {
            reply_error(desc, ENOMEM);  /* QQQ Better error?? */
        } else {
            desc->valmap_imageptr[index] = c->o.ret_gdImagePtr;
            reply_ok_valmap(desc, am_valmap_imageptr, index);
        }
        break;
    case _GDIMAGECREATEFROMXPM:
        if (! c->o.__expect) {
            reply_error(desc, c->o.__expect_errval);
            break;
        }
        if (find_unused_imageptr_index(desc, &index) < 0) {
            reply_error(desc, ENOMEM);  /* QQQ Better error?? */
        } else {
            desc->valmap_imageptr[index] = c->o.ret_gdImagePtr;
            reply_ok_valmap(desc, am_valmap_imageptr, index);
        }
        break;
    case _GDIMAGECOLORALLOCATE:
        if (c->o.__expect) {
            reply_ok_num(desc, c->o.ret_int);
        } else {
            reply_error(desc, c->o.__expect_errval);
        }
        break;
    case _GDIMAGECOLORCLOSEST:
        if (c->o.__expect) {
            reply_ok_num(desc, c->o.ret_int);
        } else {
            reply_error(desc, c->o.__expect_errval);
        }
        break;
    case _GDIMAGECOLOREXACT:
        if (c->o.__expect) {
            reply_ok_num(desc, c->o.ret_int);
        } else {
            reply_error(desc, c->o.__expect_errval);
        }
        break;
    case _GDIMAGECOLORRESOLVE:
        if (c->o.__expect) {
            reply_ok_num(desc, c->o.ret_int);
        } else {
            reply_error(desc, c->o.__expect_errval);
        }
        break;
    case _GDIMAGECOLORSTOTAL:
        if (c->o.__expect) {
            reply_ok_num(desc, c->o.ret_int);
        } else {
            reply_error(desc, c->o.__expect_errval);
        }
        break;
    case _GDIMAGEGETINTERLACED:
        if (c->o.__expect) {
            reply_ok_num(desc, c->o.ret_int);
        } else {
            reply_error(desc, c->o.__expect_errval);
        }
        break;
    case _GDIMAGEGETTRANSPARENT:
        if (c->o.__expect) {
            reply_ok_num(desc, c->o.ret_int);
        } else {
            reply_error(desc, c->o.__expect_errval);
        }
        break;
    case _GDIMAGECOLORDEALLOCATE:
        reply_ok(desc);
        break;
    case _GDIMAGECOLORTRANSPARENT:
        reply_ok(desc);
        break;
    case _GDIMAGESETPIXEL:
        reply_ok(desc);
        break;
    case _GDIMAGELINE:
        reply_ok(desc);
        break;
    case _GDIMAGEPOLYGON:
        if (c->o.__expect) {
            reply_ok_num(desc, c->o.ret_int);
        } else {
            reply_error(desc, c->o.__expect_errval);
        }
        break;
    case _GDIMAGEFILLEDPOLYGON:
        if (c->o.__expect) {
            reply_ok_num(desc, c->o.ret_int);
        } else {
            reply_error(desc, c->o.__expect_errval);
        }
        break;
    case _GDIMAGERECTANGLE:
        reply_ok(desc);
        break;
    case _GDIMAGEFILLEDRECTANGLE:
        reply_ok(desc);
        break;
    case _GDIMAGEARC:
        reply_ok(desc);
        break;
    case _GDIMAGEFILLTOBORDER:
        reply_ok(desc);
        break;
    case _GDIMAGEFILL:
        reply_ok(desc);
        break;
    case _GDIMAGESETBRUSH:
        reply_ok(desc);
        break;
    case _GDIMAGESETTILE:
        reply_ok(desc);
        break;
    case _GDIMAGESETSTYLE:
        if (c->o.__expect) {
            reply_ok_num(desc, c->o.ret_int);
        } else {
            reply_error(desc, c->o.__expect_errval);
        }
        break;
    case _GDIMAGEGETPIXEL:
        reply_ok_num(desc, c->o.ret_int);
        break;
    case _GDIMAGERED:
        reply_ok_num(desc, c->o.ret_int);
        break;
    case _GDIMAGEGREEN:
        reply_ok_num(desc, c->o.ret_int);
        break;
    case _GDIMAGEBLUE:
        reply_ok_num(desc, c->o.ret_int);
        break;
    case _GDIMAGEBOUNDSSAFE:
        reply_ok_num(desc, c->o.ret_int);
        break;
    case _GDIMAGESX:
        reply_ok_num(desc, c->o.ret_int);
        break;
    case _GDIMAGESY:
        reply_ok_num(desc, c->o.ret_int);
        break;
    case _GDIMAGEPNG:
        if (c->o.__expect) {
            reply_ok_num(desc, c->o.ret_int);
        } else {
            reply_error(desc, c->o.__expect_errval);
        }
        break;
    case _GDIMAGEPNGPTR:
        bytes = c->o.size;
        offset = 0;
        if ((p = edtk_driver_alloc_wrapper(bytes)) == NULL) {
            reply_error(desc, ENOMEM);
        } else {
            memcpy(p, c->o.ret_void_p, bytes);
            reply_ok_binary(desc, p, 0, bytes);
        }
        /* <hack place="ready_async-post-reply" type="verbatim"> */

        if (c->o.ret_void_p != NULL) gdFree(c->o.ret_void_p);
 
        /* </hack --place="ready_async-post-reply" type="verbatim"--> */
        break;
    case _GDIMAGEPNGPTR_QQQ_DELETEME:
        reply_xtra_void_p_and_size(desc, c);
        /* <hack place="ready_async-post-reply" type="verbatim"> */

        if (c->o.ret_void_p != NULL) gdFree(c->o.ret_void_p);
 
        /* </hack --place="ready_async-post-reply" type="verbatim"--> */
        break;
    case _GDIMAGEJPEG:
        if (c->o.__expect) {
            reply_ok_num(desc, c->o.ret_int);
        } else {
            reply_error(desc, c->o.__expect_errval);
        }
        break;
    case _GDIMAGEJPEGPTR:
        bytes = c->o.size;
        offset = 0;
        if ((p = edtk_driver_alloc_wrapper(bytes)) == NULL) {
            reply_error(desc, ENOMEM);
        } else {
            memcpy(p, c->o.ret_void_p, bytes);
            reply_ok_binary(desc, p, 0, bytes);
        }
        /* <hack place="ready_async-post-reply" type="verbatim"> */

        if (c->o.ret_void_p != NULL) gdFree(c->o.ret_void_p);
 
        /* </hack --place="ready_async-post-reply" type="verbatim"--> */
        break;
    case _GDIMAGEWBMP:
        if (c->o.__expect) {
            reply_ok_num(desc, c->o.ret_int);
        } else {
            reply_error(desc, c->o.__expect_errval);
        }
        break;
    case _GDIMAGEWBMPPTR:
        bytes = c->o.size;
        offset = 0;
        if ((p = edtk_driver_alloc_wrapper(bytes)) == NULL) {
            reply_error(desc, ENOMEM);
        } else {
            memcpy(p, c->o.ret_void_p, bytes);
            reply_ok_binary(desc, p, 0, bytes);
        }
        /* <hack place="ready_async-post-reply" type="verbatim"> */

        if (c->o.ret_void_p != NULL) gdFree(c->o.ret_void_p);
 
        /* </hack --place="ready_async-post-reply" type="verbatim"--> */
        break;
    case _GDIMAGEGD:
        if (c->o.__expect) {
            reply_ok_num(desc, c->o.ret_int);
        } else {
            reply_error(desc, c->o.__expect_errval);
        }
        break;
    case _GDIMAGEGDPTR:
        bytes = c->o.size;
        offset = 0;
        if ((p = edtk_driver_alloc_wrapper(bytes)) == NULL) {
            reply_error(desc, ENOMEM);
        } else {
            memcpy(p, c->o.ret_void_p, bytes);
            reply_ok_binary(desc, p, 0, bytes);
        }
        /* <hack place="ready_async-post-reply" type="verbatim"> */

        if (c->o.ret_void_p != NULL) gdFree(c->o.ret_void_p);
 
        /* </hack --place="ready_async-post-reply" type="verbatim"--> */
        break;
    case _GDIMAGEGD2:
        if (c->o.__expect) {
            reply_ok_num(desc, c->o.ret_int);
        } else {
            reply_error(desc, c->o.__expect_errval);
        }
        break;
    case _GDIMAGEGD2PTR:
        bytes = c->o.size;
        offset = 0;
        if ((p = edtk_driver_alloc_wrapper(bytes)) == NULL) {
            reply_error(desc, ENOMEM);
        } else {
            memcpy(p, c->o.ret_void_p, bytes);
            reply_ok_binary(desc, p, 0, bytes);
        }
        /* <hack place="ready_async-post-reply" type="verbatim"> */

        if (c->o.ret_void_p != NULL) gdFree(c->o.ret_void_p);
 
        /* </hack --place="ready_async-post-reply" type="verbatim"--> */
        break;
    case _FOPEN:
        if (! c->o.__expect) {
            reply_error(desc, c->o.__expect_errval);
            break;
        }
        if (find_unused_FILE_P_index(desc, &index) < 0) {
            reply_error(desc, ENOMEM);  /* QQQ Better error?? */
        } else {
            desc->valmap_FILE_P[index] = c->o.filep;
            reply_ok_valmap(desc, am_valmap_FILE_P, index);
        }
        break;
    case _FCLOSE:
        if (! c->o.__expect) {
            reply_error(desc, c->o.__expect_errval);
            break;
        }
        cleanup_valmap_FILE_P_index(desc, c->i.__valmap_FILE_P_index, 0);
        reply_ok_num(desc, c->o.ret_int);
        break;
    case _GDIMAGEPNGFILE:
        reply_ok(desc);
        break;
    case _GDIMAGEJPEGFILE:
        reply_ok(desc);
        break;
    case _GDIMAGEDESTROY:
        cleanup_valmap_imageptr_index(desc, c->i.__valmap_imageptr_index, 0);
        reply_ok(desc);
        break;
    case _GETFONTPTR:
        if (! c->o.__expect) {
            reply_error(desc, c->o.__expect_errval);
            break;
        }
        if (find_unused_fontptr_index(desc, &index) < 0) {
            reply_error(desc, ENOMEM);  /* QQQ Better error?? */
        } else {
            desc->valmap_fontptr[index] = c->o.ret_gdFontPtr;
            reply_ok_valmap(desc, am_valmap_fontptr, index);
        }
        break;
    case _GDIMAGECHAR:
        reply_ok(desc);
        break;
    case _GDIMAGECHARUP:
        reply_ok(desc);
        break;
    case _GDIMAGESTRING:
        reply_ok(desc);
        break;
    case _GDIMAGESTRINGUP:
        reply_ok(desc);
        break;
    case _GDIMAGECOPY:
        reply_ok(desc);
        break;
    case _GDIMAGECOPYRESIZED:
        reply_ok(desc);
        break;
    case _GDIMAGECOPYMERGE:
        reply_ok(desc);
        break;
    case _GDIMAGECOPYMERGEGRAY:
        reply_ok(desc);
        break;
    case _GDIMAGEPALETTECOPY:
        reply_ok(desc);
        break;
    case _GDIMAGECOMPARE:
        reply_ok_num(desc, c->o.ret_int);
        break;
    case _GDIMAGEINTERLACE:
        reply_ok(desc);
        break;
    default:
        edtk_debug("%s: bogus command, should never happen", __FUNCTION__);
        break;
    }    
    sys_free(c);
}

static void
invoke__gdImageCreate(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_gdImagePtr = gdImageCreate(
                          c->i.sx, 
                          c->i.sy
                        );
    if (c->o.ret_gdImagePtr != NULL) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = 0;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageCreateFromJpeg(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_gdImagePtr = my_gdImageCreateFromJpeg(
                          c->i.filename, 
                         & c->o.status
                        );
    if (c->o.ret_gdImagePtr != NULL) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = c->o.status;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageCreateFromPng(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_gdImagePtr = my_gdImageCreateFromPng(
                          c->i.filename, 
                         & c->o.status
                        );
    if (c->o.ret_gdImagePtr != NULL) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = c->o.status;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageCreateFromGd(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_gdImagePtr = my_gdImageCreateFromGd(
                          c->i.filename, 
                         & c->o.status
                        );
    if (c->o.ret_gdImagePtr != NULL) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = c->o.status;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageCreateFromGd2(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_gdImagePtr = my_gdImageCreateFromGd2(
                          c->i.filename, 
                         & c->o.status
                        );
    if (c->o.ret_gdImagePtr != NULL) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = c->o.status;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageCreateFromGd2Part(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_gdImagePtr = my_gdImageCreateFromGd2Part(
                          c->i.filename, 
                          c->i.srcX, 
                          c->i.srcY, 
                          c->i.h, 
                          c->i.w, 
                         & c->o.status
                        );
    if (c->o.ret_gdImagePtr != NULL) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = c->o.status;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageCreateFromXpm(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_gdImagePtr = my_gdImageCreateFromXpm(
                          c->i.filename, 
                         & c->o.status
                        );
    if (c->o.ret_gdImagePtr != NULL) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = c->o.status;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageColorAllocate(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_int = gdImageColorAllocate(
                          c->i.im, 
                          c->i.r, 
                          c->i.g, 
                          c->i.b
                        );
    if (c->o.ret_int >= 0) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = -1;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageColorClosest(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_int = gdImageColorClosest(
                          c->i.im, 
                          c->i.r, 
                          c->i.g, 
                          c->i.b
                        );
    if (c->o.ret_int >= 0) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = -1;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageColorExact(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_int = gdImageColorExact(
                          c->i.im, 
                          c->i.r, 
                          c->i.g, 
                          c->i.b
                        );
    if (c->o.ret_int >= 0) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = -1;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageColorResolve(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_int = gdImageColorResolve(
                          c->i.im, 
                          c->i.r, 
                          c->i.g, 
                          c->i.b
                        );
    if (c->o.ret_int >= 0) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = -1;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageColorsTotal(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_int = gdImageColorsTotal(
                          c->i.im
                        );
    if (c->o.ret_int >= 0) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = -1;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageGetInterlaced(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_int = gdImageGetInterlaced(
                          c->i.im
                        );
    if (c->o.ret_int >= 0) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = -1;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageGetTransparent(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_int = gdImageGetTransparent(
                          c->i.im
                        );
    if (c->o.ret_int >= 0) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = -1;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageColorDeallocate(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    gdImageColorDeallocate(
                          c->i.im, 
                          c->i.color
                        );
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageColorTransparent(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    gdImageColorTransparent(
                          c->i.im, 
                          c->i.color
                        );
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageSetPixel(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    gdImageSetPixel(
                          c->i.im, 
                          c->i.x, 
                          c->i.y, 
                          c->i.color
                        );
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageLine(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    gdImageLine(
                          c->i.im, 
                          c->i.x1, 
                          c->i.y1, 
                          c->i.x2, 
                          c->i.y2, 
                          c->i.color
                        );
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImagePolygon(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_int = my_gdImagePolygon(
                          c->i.im, 
                          c->i.points, 
                          c->i.pointsTotal, 
                          c->i.color
                        );
    if (c->o.ret_int == 0) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = -1;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageFilledPolygon(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_int = my_gdImageFilledPolygon(
                          c->i.im, 
                          c->i.points, 
                          c->i.pointsTotal, 
                          c->i.color
                        );
    if (c->o.ret_int == 0) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = -1;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageRectangle(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    gdImageRectangle(
                          c->i.im, 
                          c->i.x1, 
                          c->i.y1, 
                          c->i.x2, 
                          c->i.y2, 
                          c->i.color
                        );
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageFilledRectangle(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    gdImageFilledRectangle(
                          c->i.im, 
                          c->i.x1, 
                          c->i.y1, 
                          c->i.x2, 
                          c->i.y2, 
                          c->i.color
                        );
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageArc(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    gdImageArc(
                          c->i.im, 
                          c->i.cx, 
                          c->i.cy, 
                          c->i.w, 
                          c->i.h, 
                          c->i.s, 
                          c->i.e, 
                          c->i.color
                        );
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageFillToBorder(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    gdImageFillToBorder(
                          c->i.im, 
                          c->i.x, 
                          c->i.y, 
                          c->i.border, 
                          c->i.color
                        );
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageFill(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    gdImageFill(
                          c->i.im, 
                          c->i.x, 
                          c->i.y, 
                          c->i.color
                        );
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageSetBrush(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    gdImageSetBrush(
                          c->i.im, 
                          c->i.brush
                        );
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageSetTile(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    gdImageSetTile(
                          c->i.im, 
                          c->i.brush
                        );
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageSetStyle(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_int = my_gdImageSetStyle(
                          c->i.im, 
                          c->i.style, 
                          c->i.styleLength
                        );
    if (c->o.ret_int == 0) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = -1;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageGetPixel(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_int = gdImageGetPixel(
                          c->i.im, 
                          c->i.x, 
                          c->i.y
                        );
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageRed(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_int = gdImageRed(
                          c->i.im, 
                          c->i.color
                        );
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageGreen(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_int = gdImageGreen(
                          c->i.im, 
                          c->i.color
                        );
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageBlue(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_int = gdImageBlue(
                          c->i.im, 
                          c->i.color
                        );
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageBoundsSafe(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_int = gdImageBoundsSafe(
                          c->i.im, 
                          c->i.x, 
                          c->i.y
                        );
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageSX(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_int = gdImageSX(
                          c->i.im
                        );
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageSY(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_int = gdImageSY(
                          c->i.im
                        );
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImagePng(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_int = my_gdImagePng(
                          c->i.im, 
                          c->i.filename
                        );
    if (c->o.ret_int == 0) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = c->o.ret_int;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImagePngPtr(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_void_p = gdImagePngPtr(
                          c->i.im, 
                         & c->o.size
                        );
    if (c->o.ret_void_p != NULL) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = -1;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImagePngPtr_QQQ_deleteme(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_void_p = gdImagePngPtr(
                          c->i.im, 
                         & c->o.size
                        );
    if (c->o.ret_void_p != NULL) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = -1;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageJpeg(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_int = my_gdImageJpeg(
                          c->i.im, 
                          c->i.filename, 
                          c->i.quality
                        );
    if (c->o.ret_int == 0) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = c->o.ret_int;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageJpegPtr(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_void_p = gdImageJpegPtr(
                          c->i.im, 
                         & c->o.size, 
                          c->i.quality
                        );
    if (c->o.ret_void_p != NULL) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = -1;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageWBMP(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_int = my_gdImageWBMP(
                          c->i.im, 
                          c->i.fg, 
                          c->i.filename
                        );
    if (c->o.ret_int == 0) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = c->o.ret_int;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageWBMPPtr(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_void_p = gdImageWBMPPtr(
                          c->i.im, 
                         & c->o.size, 
                          c->i.fg
                        );
    if (c->o.ret_void_p != NULL) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = -1;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageGd(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_int = my_gdImageGd(
                          c->i.im, 
                          c->i.filename
                        );
    if (c->o.ret_int == 0) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = c->o.ret_int;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageGdPtr(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_void_p = gdImageGdPtr(
                          c->i.im, 
                         & c->o.size
                        );
    if (c->o.ret_void_p != NULL) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = -1;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageGd2(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_int = my_gdImageGd2(
                          c->i.im, 
                          c->i.filename, 
                          c->i.chunkSize, 
                          c->i.fmt
                        );
    if (c->o.ret_int == 0) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = c->o.ret_int;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageGd2Ptr(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_void_p = gdImageGd2Ptr(
                          c->i.im, 
                          c->i.chunkSize, 
                          c->i.fmt, 
                         & c->o.size
                        );
    if (c->o.ret_void_p != NULL) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = -1;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__fopen(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.filep = fopen(
                          c->i.path, 
                          c->i.fmode
                        );
    if (c->o.filep != NULL) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = errno;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__fclose(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_int = fclose(
                          c->i.filep
                        );
    if (c->o.ret_int == 0) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = errno;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImagePngFILE(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    gdImagePng(
                          c->i.im, 
                          c->i.outFile
                        );
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageJpegFILE(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    gdImageJpeg(
                          c->i.im, 
                          c->i.outFile, 
                          c->i.quality
                        );
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageDestroy(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    gdImageDestroy(
                          c->i.im
                        );
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__getFontPtr(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_gdFontPtr = my_GetFontPtr(
                          c->i.font_idx
                        );
    if (c->o.ret_gdFontPtr != NULL) {
        c->o.__expect = 1;
    } else {
        c->o.__expect = 0;
        c->o.__expect_errval = 0;
        /* Danger!  Do not put debugging statement before saving error val! */
        edtk_debug("%s: threadid = %lx expectation failed!", __FUNCTION__, pthread_self());
    }
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageChar(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    gdImageChar(
                          c->i.im, 
                          c->i.font, 
                          c->i.x, 
                          c->i.y, 
                          c->i.c, 
                          c->i.color
                        );
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageCharUp(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    gdImageCharUp(
                          c->i.im, 
                          c->i.font, 
                          c->i.x, 
                          c->i.y, 
                          c->i.c, 
                          c->i.color
                        );
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageString(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    gdImageString(
                          c->i.im, 
                          c->i.font, 
                          c->i.x, 
                          c->i.y, 
                          c->i.string, 
                          c->i.color
                        );
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageStringUp(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    gdImageStringUp(
                          c->i.im, 
                          c->i.font, 
                          c->i.x, 
                          c->i.y, 
                          c->i.string, 
                          c->i.color
                        );
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageCopy(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    gdImageCopy(
                          c->i.dst, 
                          c->i.src, 
                          c->i.dstX, 
                          c->i.dstY, 
                          c->i.srcX, 
                          c->i.srcY, 
                          c->i.w, 
                          c->i.h
                        );
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageCopyResized(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    gdImageCopyResized(
                          c->i.dst, 
                          c->i.src, 
                          c->i.dstX, 
                          c->i.dstY, 
                          c->i.srcX, 
                          c->i.srcY, 
                          c->i.destW, 
                          c->i.destH, 
                          c->i.srcW, 
                          c->i.srcH
                        );
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageCopyMerge(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    gdImageCopyMerge(
                          c->i.dst, 
                          c->i.src, 
                          c->i.dstX, 
                          c->i.dstY, 
                          c->i.srcX, 
                          c->i.srcY, 
                          c->i.w, 
                          c->i.h, 
                          c->i.pct
                        );
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageCopyMergeGray(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    gdImageCopyMergeGray(
                          c->i.dst, 
                          c->i.src, 
                          c->i.dstX, 
                          c->i.dstY, 
                          c->i.srcX, 
                          c->i.srcY, 
                          c->i.w, 
                          c->i.h, 
                          c->i.pct
                        );
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImagePaletteCopy(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    gdImagePaletteCopy(
                          c->i.dst, 
                          c->i.src
                        );
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageCompare(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    c->o.ret_int = gdImageCompare(
                          c->i.dst, 
                          c->i.src
                        );
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}

static void
invoke__gdImageInterlace(void *data)
{
    callstate_t *c = (callstate_t *) data;

    c = c;
    edtk_debug("%s: threadid = %lx", __FUNCTION__, pthread_self());
    gdImageInterlace(
                          c->i.dst, 
                          c->i.interlace
                        );
    edtk_debug("%s: threadid = %lx done", __FUNCTION__, pthread_self());
}


static int
reply_ok(descriptor_t *desc)
{
    ErlDrvTermData      msg[15]; /* XXX too big */
    int                 i = 0;
    int                 res;

    i = LOAD_PORT(msg, i, driver_mk_port(desc->port));
    i = LOAD_ATOM(msg, i, am_ok);
    i = LOAD_TUPLE(msg, i, 2);
    edtk_debug("reply_ok: i = %d", i);
    res = driver_output_term(desc->port, msg, i);
    edtk_debug("reply_ok: res = %d", res);
    return res;
}

static int
reply_ok_num(descriptor_t *desc, unsigned long num)
{
    ErlDrvTermData      msg[15]; /* XXX too big */
    int                 i = 0;
    int                 res;

    i = LOAD_PORT(msg, i, driver_mk_port(desc->port));
    i = LOAD_ATOM(msg, i, am_ok);
    i = LOAD_INT(msg, i, num);
    i = LOAD_TUPLE(msg, i, 3);
    edtk_debug("%s: i = %d, num = %lu", __FUNCTION__, i, num);
    res = driver_output_term(desc->port, msg, i);
    edtk_debug("%s: res = %d", __FUNCTION__, res);
    return res;
}

static int
reply_ok_binary(descriptor_t *desc, char *ptr, int beg_offset, int length)
{
    ErlDrvTermData      msg[15]; /* XXX too big */
    int                 i = 0;
    int                 res;

    i = LOAD_PORT(msg, i, driver_mk_port(desc->port));
    i = LOAD_ATOM(msg, i, am_ok);
    i = LOAD_BINARY(msg, i, edtk_alloced_ptr2ErlDrvBinary(ptr),
                    beg_offset, length);
    i = LOAD_TUPLE(msg, i, 3);
    edtk_debug("%s: i = %d, ptr = 0x%lx, start = %d, end = %d",
    __FUNCTION__, i, ptr, beg_offset, length);
    res = driver_output_term(desc->port, msg, i);
    /* driver_output_term() incrs refc, and we're done, so decr refc */
    /*
    ** We _know_ that "ptr" points to memory allocated by
    ** edtk_driver_alloc_wrapper(), so edtk_alloced_ptr2ErlDrvBinary()
    ** is safe in this case.  If it weren't safe, then the binary
    ** must be returned by an xtra_return, which means we
    ** reply_ok_binary()) are never called!
    */
    driver_free_binary(edtk_alloced_ptr2ErlDrvBinary(ptr));
    edtk_debug("%s: res = %d", __FUNCTION__, res);
    return res;
}

static int
reply_ok_valmap(descriptor_t *desc, ErlDrvTermData valmap_atom,
                unsigned long valmap_index)
{
    ErlDrvTermData      msg[15];
    int                 i = 0;
    int                 res;

    i = LOAD_PORT(msg, i, driver_mk_port(desc->port));
    i = LOAD_ATOM(msg, i, am_ok);
    i = LOAD_ATOM(msg, i, valmap_atom);
    i = LOAD_INT(msg, i, valmap_index);
    i = LOAD_TUPLE(msg, i, 2);
    i = LOAD_TUPLE(msg, i, 3);
    edtk_debug("reply_ok_valmap: i = %d", i);
    res = driver_output_term(desc->port, msg, i);
    edtk_debug("reply_ok_valmap: res = %d", res);
    return res;
}

static int
reply_error(descriptor_t *desc, int errnum)
{
    ErlDrvTermData      msg[15]; /* XXX too big */
    int                 i = 0;
    int                 res;

    edtk_debug("reply_error: errnum = %d", errnum);
    i = LOAD_PORT(msg, i, driver_mk_port(desc->port));
    i = LOAD_ATOM(msg, i, am_error);
    i = LOAD_INT(msg, i, errnum);
    i = LOAD_TUPLE(msg, i, 3);
    edtk_debug("reply_error: i = %d", i);
    res = driver_output_term(desc->port, msg, i);
    edtk_debug("reply_error: res = %d", res);
    return res;
}

static int
reply_error_atom(descriptor_t *desc, ErlDrvTermData atom)
{
    ErlDrvTermData      msg[15]; /* XXX too big */
    int                 i = 0;
    int                 res;

    i = LOAD_PORT(msg, i, driver_mk_port(desc->port));
    i = LOAD_ATOM(msg, i, am_error);
    i = LOAD_ATOM(msg, i, atom);
    i = LOAD_TUPLE(msg, i, 3);
    edtk_debug("%s: i = %d", __FUNCTION__, i);
    res = driver_output_term(desc->port, msg, i);
    edtk_debug("%s: res = %d", __FUNCTION__, res);
    return res;
}

#if     0       /* QQQ These are unused right now */
static int
reply_tag_ok(descriptor_t *desc, unsigned short tag)
{
    ErlDrvTermData      msg[15]; /* XXX too big */
    int                 i = 0;
    int                 res;

    i = LOAD_PORT(msg, i, driver_mk_port(desc->port));
    i = LOAD_INT(msg, i, tag);
    i = LOAD_ATOM(msg, i, am_ok);
    i = LOAD_TUPLE(msg, i, 3);
    edtk_debug("reply_ok: i = %d", i);
    res = driver_output_term(desc->port, msg, i);
    edtk_debug("reply_ok: res = %d", res);
    return res;
}

static int
reply_tag_error(descriptor_t *desc, unsigned short tag, int errnum)
{
    ErlDrvTermData      msg[15]; /* XXX too big */
    int                 i = 0;
    int                 res;

    edtk_debug("reply_error: errnum = %d", errnum);
    i = LOAD_PORT(msg, i, driver_mk_port(desc->port));
    i = LOAD_INT(msg, i, tag);
    i = LOAD_INT(msg, i, errnum);
    i = LOAD_ATOM(msg, i, am_error);
    i = LOAD_TUPLE(msg, i, 4);
    edtk_debug("reply_error: i = %d", i);
    res = driver_output_term(desc->port, msg, i);
    edtk_debug("reply_error: res = %d", res);
    return res;
}
#endif  /* 0 */


static int
reply_xtra_void_p_and_size(descriptor_t *desc, callstate_t *c)
{
    ErlDrvTermData      msg[64];
    int                 msgcount = 0;
    int                 res;
    int                 members = 0;
    char                *tmp = NULL;
    ErlDrvBinary        *tofree[64];
    int                 num_tofree = 0;
    int                 i;
    ErlDrvBinary        *tmpbin = NULL;

    tmp = tmp; tmpbin = tmpbin;
    msgcount = LOAD_PORT(msg, msgcount, driver_mk_port(desc->port));
    members = 2;        /* Rather, members will be 2 very shortly */
    if (c->o.__expect) {
        msgcount = LOAD_ATOM(msg, msgcount, am_ok);
        {
            int members = 0;
             if ((tmp = edtk_driver_alloc_wrapper(c->o.size)) == NULL) {
              return reply_error(desc, ENOMEM);
             }
             memcpy(tmp,  c->o.ret_void_p, c->o.size);
             tmpbin = edtk_alloced_ptr2ErlDrvBinary(tmp);
             msgcount = LOAD_BINARY(msg, msgcount, tmpbin, 0, c->o.size);
             /* driver_output_term() incrs refc, and we're done, so decr refc LATER */
             tofree[num_tofree++] = tmpbin;
             members++;
            msgcount = LOAD_TUPLE(msg, msgcount, members);
        }
    } else {
        msgcount = LOAD_ATOM(msg, msgcount, am_error);
        {
            int members = 0;
             msgcount = LOAD_INT(msg, msgcount, -1);
             members++;
            msgcount = LOAD_TUPLE(msg, msgcount, members);
        }
    }
    msgcount = LOAD_TUPLE(msg, msgcount, 3);
    edtk_debug("reply_xtra_void_p_and_size: i = %d", msgcount);
    res = driver_output_term(desc->port, msg, msgcount);
    edtk_debug("reply_xtra_void_p_and_size: res = %d", res);
    if (res < 0) {
        fprintf(stderr, "\r\n\r\nreply_xtra_void_p_and_size: driver_output_term() failed!  This should never happen!\r\n\r\n");
    }

    for (i = 0; i < num_tofree; i++) {
        driver_free_binary(tofree[i]);
    }
    return res;
}


static int
find_unused_imageptr_index(descriptor_t *desc, unsigned long *index_p)
{
    int i;

    for (i = 0; i < 32; i++) {
        if (desc->valmap_imageptr[i] == NULL) {
            *index_p = i;
            return 0;
        }
    }
    return -1;
}

static void
cleanup_valmap_imageptr_index(descriptor_t *desc, int i, int do_cleanup_func)
{
    edtk_debug("%s: i = %d, do_cleanup_func = %d", __FUNCTION__, i, do_cleanup_func);
    if (do_cleanup_func) {
        edtk_debug("%s: calling func gdImageDestroy", __FUNCTION__);
        gdImageDestroy(desc->valmap_imageptr[i]);
    }
    desc->valmap_imageptr[i] = NULL;
}

static void
cleanup_valmap_imageptr_all(descriptor_t *desc, int do_cleanup_func)
{
    int i;

    edtk_debug("%s: do_cleanup_func = %d", __FUNCTION__, do_cleanup_func);
    for (i = 0; i < 32; i++) {
        cleanup_valmap_imageptr_index(desc, i, do_cleanup_func);
    }
}

static int
find_unused_FILE_P_index(descriptor_t *desc, unsigned long *index_p)
{
    int i;

    for (i = 0; i < 8; i++) {
        if (desc->valmap_FILE_P[i] == NULL) {
            *index_p = i;
            return 0;
        }
    }
    return -1;
}

static void
cleanup_valmap_FILE_P_index(descriptor_t *desc, int i, int do_cleanup_func)
{
    edtk_debug("%s: i = %d, do_cleanup_func = %d", __FUNCTION__, i, do_cleanup_func);
    if (do_cleanup_func) {
        edtk_debug("%s: calling func fclose", __FUNCTION__);
        fclose(desc->valmap_FILE_P[i]);
    }
    desc->valmap_FILE_P[i] = NULL;
}

static void
cleanup_valmap_FILE_P_all(descriptor_t *desc, int do_cleanup_func)
{
    int i;

    edtk_debug("%s: do_cleanup_func = %d", __FUNCTION__, do_cleanup_func);
    for (i = 0; i < 8; i++) {
        cleanup_valmap_FILE_P_index(desc, i, do_cleanup_func);
    }
}

static int
find_unused_fontptr_index(descriptor_t *desc, unsigned long *index_p)
{
    int i;

    for (i = 0; i < 32; i++) {
        if (desc->valmap_fontptr[i] == NULL) {
            *index_p = i;
            return 0;
        }
    }
    return -1;
}

static void
cleanup_valmap_fontptr_index(descriptor_t *desc, int i, int do_cleanup_func)
{
}

static void
cleanup_valmap_fontptr_all(descriptor_t *desc, int do_cleanup_func)
{
}


