%%%----------------------------------------------------------------------
%%% File    : gd1_drv.erl
%%% Summary : An Erlang driver interface for libgd version 1
%%%
%%%
%%% NOTICE: This file was generated by the tools of the Erlang Driver
%%%         toolkit.  Do not edit this file by hand unless you know
%%%         what you're doing!
%%%
%%% Copyright (c) 2002, Scott Lystig Fritchie.  All rights reserved.
%%% See the file "LICENSE" at the top of the source distribution for
%%% full license terms.
%%%
%%%----------------------------------------------------------------------

-module(gd1_drv).
-include("gd1_drv.hrl").

%% Xref with erl_driver_tk.h's PIPE_DRIVER_TERM_* values
-define(T_NIL, 0).
-define(T_ATOM, 1).
-define(T_PORT, 2).
-define(T_INT, 3).
-define(T_TUPLE, 4).
-define(T_BINARY, 5).
-define(T_STRING, 6).
-define(T_LIST, 7).

%% External exports

-export([make_vertex_array/1, make_style_array/1]).
 
-export([start/0, start_pipe/0]).
-export([shutdown/1]).
-export([debug/2]).
-export([
         gdImageCreate/3, 
         gdImageCreateFromJpeg/2, 
         gdImageCreateFromPng/2, 
         gdImageCreateFromGd/2, 
         gdImageCreateFromGd2/2, 
         gdImageCreateFromGd2Part/6, 
         gdImageCreateFromXpm/2, 
         gdImageColorAllocate/5, 
         gdImageColorClosest/5, 
         gdImageColorExact/5, 
         gdImageColorResolve/5, 
         gdImageColorsTotal/2, 
         gdImageGetInterlaced/2, 
         gdImageGetTransparent/2, 
         gdImageColorDeallocate/3, 
         gdImageColorTransparent/3, 
         gdImageSetPixel/5, 
         gdImageLine/7, 
         gdImagePolygon/5, 
         gdImageFilledPolygon/5, 
         gdImageRectangle/7, 
         gdImageFilledRectangle/7, 
         gdImageArc/9, 
         gdImageFillToBorder/6, 
         gdImageFill/5, 
         gdImageSetBrush/3, 
         gdImageSetTile/3, 
         gdImageSetStyle/4, 
         gdImageGetPixel/4, 
         gdImageRed/3, 
         gdImageGreen/3, 
         gdImageBlue/3, 
         gdImageBoundsSafe/4, 
         gdImageSX/2, 
         gdImageSY/2, 
         gdImagePng/3, 
         gdImagePngPtr/2, 
         gdImagePngPtr_QQQ_deleteme/2, 
         gdImageJpeg/4, 
         gdImageJpegPtr/3, 
         gdImageWBMP/4, 
         gdImageWBMPPtr/3, 
         gdImageGd/3, 
         gdImageGdPtr/2, 
         gdImageGd2/5, 
         gdImageGd2Ptr/4, 
         fopen/3, 
         fclose/2, 
         gdImagePngFILE/3, 
         gdImageJpegFILE/4, 
         gdImageDestroy/2, 
         getFontPtr/2, 
         gdImageChar/7, 
         gdImageCharUp/7, 
         gdImageString/7, 
         gdImageStringUp/7, 
         gdImageCopy/9, 
         gdImageCopyResized/11, 
         gdImageCopyMerge/10, 
         gdImageCopyMergeGray/10, 
         gdImagePaletteCopy/3, 
         gdImageCompare/3, 
         gdImageInterlace/3
        ]).

start() ->
    {ok, Path} = load_path(?DRV_NAME ++ ".so"),
    erl_ddll:start(),
    ok = erl_ddll:load_driver(Path, ?DRV_NAME),
    case open_port({spawn, ?DRV_NAME}, []) of
        P when port(P) ->
            {ok, P};
        Err ->
            Err
    end.

start_pipe() ->
    {ok, PipeMain} = load_path("pipe-main"),
    {ok, ShLib} = load_path("./gd1_drv.so"),
    Cmd = PipeMain ++ "/pipe-main " ++ ShLib ++ "/gd1_drv.so",
    case open_port({spawn, Cmd}, [exit_status, binary, use_stdio, {packet, 4}]) of
        P when port(P) ->
            {ok, P};
        Err ->
            Err
    end.

shutdown(Port) when port(Port) ->
    catch erlang:port_close(Port),
    %% QQQ I was under the impression you'd always get a message sent to
    %% you in this case, so this receive is to keep your mailbox from
    %% getting cluttered.  Hrm, well, sometimes the message does
    %% not arrive at all!
    receive
        {'EXIT', Port, normal} -> {ok, normal};
        {'EXIT', Port, Err}    -> {error, Err}
    after 0                    -> {ok, normall} % QQQ is 0 too small?
        
    end.

debug(Port, Flags) when port(Port), integer(Flags) ->
    case catch erlang:port_command(Port, <<?_DEBUG, Flags:32>>) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ too drastic?
    end.

gdImageCreate(Port,
     Sx, 
     Sy
        ) when port(Port) -> % TODO: Add additional constraints here
    IOList_____ = <<?_GDIMAGECREATE,
          Sx:32/integer, 
          Sy:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageCreateFromJpeg(Port,
     Filename
        ) when port(Port) -> % TODO: Add additional constraints here
    {FilenameBinOrList, FilenameLen} = serialize_contiguously(Filename, 1),
    IOList_____ = [ <<?_GDIMAGECREATEFROMJPEG,
            FilenameLen:32/integer>>,           % I/O list length
          FilenameBinOrList,
          <<
        >> ],
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageCreateFromPng(Port,
     Filename
        ) when port(Port) -> % TODO: Add additional constraints here
    {FilenameBinOrList, FilenameLen} = serialize_contiguously(Filename, 1),
    IOList_____ = [ <<?_GDIMAGECREATEFROMPNG,
            FilenameLen:32/integer>>,           % I/O list length
          FilenameBinOrList,
          <<
        >> ],
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageCreateFromGd(Port,
     Filename
        ) when port(Port) -> % TODO: Add additional constraints here
    {FilenameBinOrList, FilenameLen} = serialize_contiguously(Filename, 1),
    IOList_____ = [ <<?_GDIMAGECREATEFROMGD,
            FilenameLen:32/integer>>,           % I/O list length
          FilenameBinOrList,
          <<
        >> ],
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageCreateFromGd2(Port,
     Filename
        ) when port(Port) -> % TODO: Add additional constraints here
    {FilenameBinOrList, FilenameLen} = serialize_contiguously(Filename, 1),
    IOList_____ = [ <<?_GDIMAGECREATEFROMGD2,
            FilenameLen:32/integer>>,           % I/O list length
          FilenameBinOrList,
          <<
        >> ],
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageCreateFromGd2Part(Port,
     Filename, 
     Srcx, 
     Srcy, 
     H, 
     W
        ) when port(Port) -> % TODO: Add additional constraints here
    {FilenameBinOrList, FilenameLen} = serialize_contiguously(Filename, 1),
    IOList_____ = [ <<?_GDIMAGECREATEFROMGD2PART,
            FilenameLen:32/integer>>,           % I/O list length
          FilenameBinOrList,
          <<
          Srcx:32/integer, 
          Srcy:32/integer, 
          H:32/integer, 
          W:32/integer
        >> ],
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageCreateFromXpm(Port,
     Filename
        ) when port(Port) -> % TODO: Add additional constraints here
    {FilenameBinOrList, FilenameLen} = serialize_contiguously(Filename, 1),
    IOList_____ = [ <<?_GDIMAGECREATEFROMXPM,
            FilenameLen:32/integer>>,           % I/O list length
          FilenameBinOrList,
          <<
        >> ],
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageColorAllocate(Port,
     Im, 
     R, 
     G, 
     B
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    IOList_____ = <<?_GDIMAGECOLORALLOCATE,
            ImIndex:32/integer, 
          R:32/integer, 
          G:32/integer, 
          B:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageColorClosest(Port,
     Im, 
     R, 
     G, 
     B
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    IOList_____ = <<?_GDIMAGECOLORCLOSEST,
            ImIndex:32/integer, 
          R:32/integer, 
          G:32/integer, 
          B:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageColorExact(Port,
     Im, 
     R, 
     G, 
     B
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    IOList_____ = <<?_GDIMAGECOLOREXACT,
            ImIndex:32/integer, 
          R:32/integer, 
          G:32/integer, 
          B:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageColorResolve(Port,
     Im, 
     R, 
     G, 
     B
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    IOList_____ = <<?_GDIMAGECOLORRESOLVE,
            ImIndex:32/integer, 
          R:32/integer, 
          G:32/integer, 
          B:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageColorsTotal(Port,
     Im
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    IOList_____ = <<?_GDIMAGECOLORSTOTAL,
            ImIndex:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageGetInterlaced(Port,
     Im
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    IOList_____ = <<?_GDIMAGEGETINTERLACED,
            ImIndex:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageGetTransparent(Port,
     Im
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    IOList_____ = <<?_GDIMAGEGETTRANSPARENT,
            ImIndex:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageColorDeallocate(Port,
     Im, 
     Color
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    IOList_____ = <<?_GDIMAGECOLORDEALLOCATE,
            ImIndex:32/integer, 
          Color:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageColorTransparent(Port,
     Im, 
     Color
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    IOList_____ = <<?_GDIMAGECOLORTRANSPARENT,
            ImIndex:32/integer, 
          Color:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageSetPixel(Port,
     Im, 
     X, 
     Y, 
     Color
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    IOList_____ = <<?_GDIMAGESETPIXEL,
            ImIndex:32/integer, 
          X:32/integer, 
          Y:32/integer, 
          Color:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageLine(Port,
     Im, 
     X1, 
     Y1, 
     X2, 
     Y2, 
     Color
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    IOList_____ = <<?_GDIMAGELINE,
            ImIndex:32/integer, 
          X1:32/integer, 
          Y1:32/integer, 
          X2:32/integer, 
          Y2:32/integer, 
          Color:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImagePolygon(Port,
     Im, 
     Points, 
     Pointstotal, 
     Color
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    {PointsBinOrList, PointsLen} = serialize_contiguously(Points, 0),
    IOList_____ = [ <<?_GDIMAGEPOLYGON,
            ImIndex:32/integer, 
            PointsLen:32/integer>>,             % I/O list length
          PointsBinOrList,
          <<
          Pointstotal:32/integer, 
          Color:32/integer
        >> ],
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageFilledPolygon(Port,
     Im, 
     Points, 
     Pointstotal, 
     Color
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    {PointsBinOrList, PointsLen} = serialize_contiguously(Points, 0),
    IOList_____ = [ <<?_GDIMAGEFILLEDPOLYGON,
            ImIndex:32/integer, 
            PointsLen:32/integer>>,             % I/O list length
          PointsBinOrList,
          <<
          Pointstotal:32/integer, 
          Color:32/integer
        >> ],
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageRectangle(Port,
     Im, 
     X1, 
     Y1, 
     X2, 
     Y2, 
     Color
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    IOList_____ = <<?_GDIMAGERECTANGLE,
            ImIndex:32/integer, 
          X1:32/integer, 
          Y1:32/integer, 
          X2:32/integer, 
          Y2:32/integer, 
          Color:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageFilledRectangle(Port,
     Im, 
     X1, 
     Y1, 
     X2, 
     Y2, 
     Color
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    IOList_____ = <<?_GDIMAGEFILLEDRECTANGLE,
            ImIndex:32/integer, 
          X1:32/integer, 
          Y1:32/integer, 
          X2:32/integer, 
          Y2:32/integer, 
          Color:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageArc(Port,
     Im, 
     Cx, 
     Cy, 
     W, 
     H, 
     S, 
     E, 
     Color
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    IOList_____ = <<?_GDIMAGEARC,
            ImIndex:32/integer, 
          Cx:32/integer, 
          Cy:32/integer, 
          W:32/integer, 
          H:32/integer, 
          S:32/integer, 
          E:32/integer, 
          Color:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageFillToBorder(Port,
     Im, 
     X, 
     Y, 
     Border, 
     Color
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    IOList_____ = <<?_GDIMAGEFILLTOBORDER,
            ImIndex:32/integer, 
          X:32/integer, 
          Y:32/integer, 
          Border:32/integer, 
          Color:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageFill(Port,
     Im, 
     X, 
     Y, 
     Color
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    IOList_____ = <<?_GDIMAGEFILL,
            ImIndex:32/integer, 
          X:32/integer, 
          Y:32/integer, 
          Color:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageSetBrush(Port,
     Im, 
     Brush
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    {valmap_imageptr, BrushIndex} = Brush,
    IOList_____ = <<?_GDIMAGESETBRUSH,
            ImIndex:32/integer, 
            BrushIndex:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageSetTile(Port,
     Im, 
     Brush
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    {valmap_imageptr, BrushIndex} = Brush,
    IOList_____ = <<?_GDIMAGESETTILE,
            ImIndex:32/integer, 
            BrushIndex:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageSetStyle(Port,
     Im, 
     Style, 
     Stylelength
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    {StyleBinOrList, StyleLen} = serialize_contiguously(Style, 0),
    IOList_____ = [ <<?_GDIMAGESETSTYLE,
            ImIndex:32/integer, 
            StyleLen:32/integer>>,              % I/O list length
          StyleBinOrList,
          <<
          Stylelength:32/integer
        >> ],
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageGetPixel(Port,
     Im, 
     X, 
     Y
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    IOList_____ = <<?_GDIMAGEGETPIXEL,
            ImIndex:32/integer, 
          X:32/integer, 
          Y:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageRed(Port,
     Im, 
     Color
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    IOList_____ = <<?_GDIMAGERED,
            ImIndex:32/integer, 
          Color:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageGreen(Port,
     Im, 
     Color
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    IOList_____ = <<?_GDIMAGEGREEN,
            ImIndex:32/integer, 
          Color:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageBlue(Port,
     Im, 
     Color
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    IOList_____ = <<?_GDIMAGEBLUE,
            ImIndex:32/integer, 
          Color:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageBoundsSafe(Port,
     Im, 
     X, 
     Y
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    IOList_____ = <<?_GDIMAGEBOUNDSSAFE,
            ImIndex:32/integer, 
          X:32/integer, 
          Y:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageSX(Port,
     Im
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    IOList_____ = <<?_GDIMAGESX,
            ImIndex:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageSY(Port,
     Im
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    IOList_____ = <<?_GDIMAGESY,
            ImIndex:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImagePng(Port,
     Im, 
     Filename
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    {FilenameBinOrList, FilenameLen} = serialize_contiguously(Filename, 1),
    IOList_____ = [ <<?_GDIMAGEPNG,
            ImIndex:32/integer, 
            FilenameLen:32/integer>>,           % I/O list length
          FilenameBinOrList,
          <<
        >> ],
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImagePngPtr(Port,
     Im
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    IOList_____ = <<?_GDIMAGEPNGPTR,
            ImIndex:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImagePngPtr_QQQ_deleteme(Port,
     Im
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    IOList_____ = <<?_GDIMAGEPNGPTR_QQQ_DELETEME,
            ImIndex:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageJpeg(Port,
     Im, 
     Filename, 
     Quality
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    {FilenameBinOrList, FilenameLen} = serialize_contiguously(Filename, 1),
    IOList_____ = [ <<?_GDIMAGEJPEG,
            ImIndex:32/integer, 
            FilenameLen:32/integer>>,           % I/O list length
          FilenameBinOrList,
          <<
          Quality:32/integer
        >> ],
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageJpegPtr(Port,
     Im, 
     Quality
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    IOList_____ = <<?_GDIMAGEJPEGPTR,
            ImIndex:32/integer, 
          Quality:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageWBMP(Port,
     Im, 
     Fg, 
     Filename
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    {FilenameBinOrList, FilenameLen} = serialize_contiguously(Filename, 1),
    IOList_____ = [ <<?_GDIMAGEWBMP,
            ImIndex:32/integer, 
          Fg:32/integer, 
            FilenameLen:32/integer>>,           % I/O list length
          FilenameBinOrList,
          <<
        >> ],
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageWBMPPtr(Port,
     Im, 
     Fg
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    IOList_____ = <<?_GDIMAGEWBMPPTR,
            ImIndex:32/integer, 
          Fg:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageGd(Port,
     Im, 
     Filename
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    {FilenameBinOrList, FilenameLen} = serialize_contiguously(Filename, 1),
    IOList_____ = [ <<?_GDIMAGEGD,
            ImIndex:32/integer, 
            FilenameLen:32/integer>>,           % I/O list length
          FilenameBinOrList,
          <<
        >> ],
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageGdPtr(Port,
     Im
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    IOList_____ = <<?_GDIMAGEGDPTR,
            ImIndex:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageGd2(Port,
     Im, 
     Filename, 
     Chunksize, 
     Fmt
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    {FilenameBinOrList, FilenameLen} = serialize_contiguously(Filename, 1),
    IOList_____ = [ <<?_GDIMAGEGD2,
            ImIndex:32/integer, 
            FilenameLen:32/integer>>,           % I/O list length
          FilenameBinOrList,
          <<
          Chunksize:32/integer, 
          Fmt:32/integer
        >> ],
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageGd2Ptr(Port,
     Im, 
     Chunksize, 
     Fmt
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    IOList_____ = <<?_GDIMAGEGD2PTR,
            ImIndex:32/integer, 
          Chunksize:32/integer, 
          Fmt:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

fopen(Port,
     Path, 
     Fmode
        ) when port(Port) -> % TODO: Add additional constraints here
    {PathBinOrList, PathLen} = serialize_contiguously(Path, 1),
    {FmodeBinOrList, FmodeLen} = serialize_contiguously(Fmode, 1),
    IOList_____ = [ <<?_FOPEN,
            PathLen:32/integer>>,               % I/O list length
          PathBinOrList,
          <<
            FmodeLen:32/integer>>,              % I/O list length
          FmodeBinOrList,
          <<
        >> ],
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

fclose(Port,
     Filep
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_FILE_P, FilepIndex} = Filep,
    IOList_____ = <<?_FCLOSE,
            FilepIndex:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImagePngFILE(Port,
     Im, 
     Outfile
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    {valmap_FILE_P, OutfileIndex} = Outfile,
    IOList_____ = <<?_GDIMAGEPNGFILE,
            ImIndex:32/integer, 
            OutfileIndex:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageJpegFILE(Port,
     Im, 
     Outfile, 
     Quality
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    {valmap_FILE_P, OutfileIndex} = Outfile,
    IOList_____ = <<?_GDIMAGEJPEGFILE,
            ImIndex:32/integer, 
            OutfileIndex:32/integer, 
          Quality:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageDestroy(Port,
     Im
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    IOList_____ = <<?_GDIMAGEDESTROY,
            ImIndex:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

getFontPtr(Port,
     Font_Idx
        ) when port(Port) -> % TODO: Add additional constraints here
    IOList_____ = <<?_GETFONTPTR,
          Font_Idx:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageChar(Port,
     Im, 
     Font, 
     X, 
     Y, 
     C, 
     Color
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    {valmap_fontptr, FontIndex} = Font,
    IOList_____ = <<?_GDIMAGECHAR,
            ImIndex:32/integer, 
            FontIndex:32/integer, 
          X:32/integer, 
          Y:32/integer, 
          C:32/integer, 
          Color:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageCharUp(Port,
     Im, 
     Font, 
     X, 
     Y, 
     C, 
     Color
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    {valmap_fontptr, FontIndex} = Font,
    IOList_____ = <<?_GDIMAGECHARUP,
            ImIndex:32/integer, 
            FontIndex:32/integer, 
          X:32/integer, 
          Y:32/integer, 
          C:32/integer, 
          Color:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageString(Port,
     Im, 
     Font, 
     X, 
     Y, 
     String, 
     Color
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    {valmap_fontptr, FontIndex} = Font,
    {StringBinOrList, StringLen} = serialize_contiguously(String, 1),
    IOList_____ = [ <<?_GDIMAGESTRING,
            ImIndex:32/integer, 
            FontIndex:32/integer, 
          X:32/integer, 
          Y:32/integer, 
            StringLen:32/integer>>,             % I/O list length
          StringBinOrList,
          <<
          Color:32/integer
        >> ],
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageStringUp(Port,
     Im, 
     Font, 
     X, 
     Y, 
     String, 
     Color
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, ImIndex} = Im,
    {valmap_fontptr, FontIndex} = Font,
    {StringBinOrList, StringLen} = serialize_contiguously(String, 1),
    IOList_____ = [ <<?_GDIMAGESTRINGUP,
            ImIndex:32/integer, 
            FontIndex:32/integer, 
          X:32/integer, 
          Y:32/integer, 
            StringLen:32/integer>>,             % I/O list length
          StringBinOrList,
          <<
          Color:32/integer
        >> ],
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageCopy(Port,
     Dst, 
     Src, 
     Dstx, 
     Dsty, 
     Srcx, 
     Srcy, 
     W, 
     H
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, DstIndex} = Dst,
    {valmap_imageptr, SrcIndex} = Src,
    IOList_____ = <<?_GDIMAGECOPY,
            DstIndex:32/integer, 
            SrcIndex:32/integer, 
          Dstx:32/integer, 
          Dsty:32/integer, 
          Srcx:32/integer, 
          Srcy:32/integer, 
          W:32/integer, 
          H:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageCopyResized(Port,
     Dst, 
     Src, 
     Dstx, 
     Dsty, 
     Srcx, 
     Srcy, 
     Destw, 
     Desth, 
     Srcw, 
     Srch
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, DstIndex} = Dst,
    {valmap_imageptr, SrcIndex} = Src,
    IOList_____ = <<?_GDIMAGECOPYRESIZED,
            DstIndex:32/integer, 
            SrcIndex:32/integer, 
          Dstx:32/integer, 
          Dsty:32/integer, 
          Srcx:32/integer, 
          Srcy:32/integer, 
          Destw:32/integer, 
          Desth:32/integer, 
          Srcw:32/integer, 
          Srch:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageCopyMerge(Port,
     Dst, 
     Src, 
     Dstx, 
     Dsty, 
     Srcx, 
     Srcy, 
     W, 
     H, 
     Pct
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, DstIndex} = Dst,
    {valmap_imageptr, SrcIndex} = Src,
    IOList_____ = <<?_GDIMAGECOPYMERGE,
            DstIndex:32/integer, 
            SrcIndex:32/integer, 
          Dstx:32/integer, 
          Dsty:32/integer, 
          Srcx:32/integer, 
          Srcy:32/integer, 
          W:32/integer, 
          H:32/integer, 
          Pct:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageCopyMergeGray(Port,
     Dst, 
     Src, 
     Dstx, 
     Dsty, 
     Srcx, 
     Srcy, 
     W, 
     H, 
     Pct
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, DstIndex} = Dst,
    {valmap_imageptr, SrcIndex} = Src,
    IOList_____ = <<?_GDIMAGECOPYMERGEGRAY,
            DstIndex:32/integer, 
            SrcIndex:32/integer, 
          Dstx:32/integer, 
          Dsty:32/integer, 
          Srcx:32/integer, 
          Srcy:32/integer, 
          W:32/integer, 
          H:32/integer, 
          Pct:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImagePaletteCopy(Port,
     Dst, 
     Src
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, DstIndex} = Dst,
    {valmap_imageptr, SrcIndex} = Src,
    IOList_____ = <<?_GDIMAGEPALETTECOPY,
            DstIndex:32/integer, 
            SrcIndex:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageCompare(Port,
     Dst, 
     Src
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, DstIndex} = Dst,
    {valmap_imageptr, SrcIndex} = Src,
    IOList_____ = <<?_GDIMAGECOMPARE,
            DstIndex:32/integer, 
            SrcIndex:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

gdImageInterlace(Port,
     Dst, 
     Interlace
        ) when port(Port) -> % TODO: Add additional constraints here
    {valmap_imageptr, DstIndex} = Dst,
    IOList_____ = <<?_GDIMAGEINTERLACE,
            DstIndex:32/integer, 
          Interlace:32/integer
        >>,
    case catch erlang:port_command(Port, IOList_____) of
        true -> get_port_reply(Port);
        Err  -> throw(Err)              % QQQ Is this too drastic?
    end.

    
%%%
%%% Internal functions.
%%%

load_path(File) ->
    case lists:filter(fun(D) ->
                              case file:read_file_info(D ++ "/" ++ File) of
                                  {ok, _} -> true;
                                  _ -> false
                              end
                      end, code:get_path()) of
        [Dir|_] ->
            {ok, Dir};
        [] ->
            io:format("Error: ~s not found in code path\n", [File]),
            {error, enoent}
    end.

%%%
%%% QQQ Note that an 'xtra_return' that only returns one item in its
%%%     tuple will return {Port, ok, {Thingie}}, so we'll return
%%%     {ok, {Thingie}}, which is *sooooooo* maddening because I keep
%%%     forgetting the extra tuple wrapper.  So, if there's only one
%%%     thingie in the return tuple, strip it off!
%%%

get_port_reply(Port) when port(Port) ->
    receive
        {Port, ok} = T -> proc_reply(T);
        {Port, ok, {M}} = T -> proc_reply(T);
        {Port, ok, M} = T -> proc_reply(T);
        {Port, error, {Reason}} = T -> proc_reply(T);
        {Port, error, Reason} = T -> proc_reply(T);
        %% Pipe driver messages
        {Port, {data, Bytes}} -> proc_reply(pipedrv_deser(Port, Bytes));
        {'EXIT', Port, Reason} -> throw({port_error, Reason});  % QQQ too drastic?
        {Port, Reason} -> throw({port_error, Reason})   % QQQ too drastic?
    end.

%% This function exists to provide consistency of replies 
%% given by linked-in and pipe drivers.  The "receive" statement
%% in get_port_reply/1 is specific because we want it to be
%% very selective about what it will grab out of the mailbox.
proc_reply({Port, ok}) when port(Port) ->
    ok;
proc_reply({Port, ok, {M}}) when port(Port) ->
    {ok, M};
proc_reply({Port, ok, M}) when port(Port) ->
    {ok, M};
proc_reply({Port, error, {Reason}}) when port(Port) ->
    {error, Reason};
proc_reply({Port, error, Reason}) when port(Port) ->
    {error, Reason}.


%%% QQQ io_list_len() is an extremely useful function.  BEAM has got this
%%% implemented quite efficiently in C.  It would be *fabulous* to be able
%%% to use it from Erlang via a BIF.

io_list_len(B) when binary(B) -> {B, size(B)};
io_list_len(L) when list(L) -> io_list_len(L, 0).
io_list_len([H|T], N) ->
    if
        H >= 0, H =< 255 -> io_list_len(T, N+1);
        list(H) -> io_list_len(T, io_list_len(H,N));
        binary(H) -> io_list_len(T, size(H) + N);
        true -> throw({error, partial_len, N})
    end;
io_list_len(H, N) when binary(H) -> 
    size(H) + N;
io_list_len([], N) -> 
    N.

%%% QQQ We need to make the binary thing we're passing in contiguous
%%% because the C function we're calling is expecting a single
%%% contiguous buffer.  If IOList is ["Hello, ", <<"World">>, "!"],
%%% that binary in the middle element will end up with the argument
%%% spanning three parts of an ErlIOVec.  If that happens, then we'd
%%% have to have the driver do the dirty work of putting the argument
%%% into a single contiguous buffer.  Frankly, we're lazy, and this
%%% code is short and won't be much slower than doing it in C.

%%% 2nd arg: if 1, NUL-terminate the IOList

serialize_contiguously(B, 0) when binary(B) ->
    {B, size(B)};
serialize_contiguously([B], 0) when binary(B) ->
    {B, size(B)};
serialize_contiguously(IOList, 1) ->
    serialize_contiguously([IOList, 0], 0);
serialize_contiguously(IOList, 0) ->
    B = list_to_binary(IOList),
    {B, size(B)}.


%% pipedrv_deser/2 -- Deserialize the term that the pipe driver is
%% is returning to Erlang.  The pipe driver doesn't know it's a pipe
%% driver, it thinks it's a linked-in driver, so it tries to return
%% an arbitrary Erlang term to us.  The pipe-main program is sneaky:
%% it has a driver_output_term() function that serializes the term
%% that the driver built.  With the help of a list-as-stack, we
%% deserialize that term.

pipedrv_deser(Port, B) ->
    pipedrv_deser(Port, B, []).

pipedrv_deser(Port, <<>>, []) ->
    throw(icky_i_think);
pipedrv_deser(Port, <<>>, [T]) ->
    T;
pipedrv_deser(Port, <<?T_NIL:8, Rest/binary>>, Stack) ->
    pipedrv_deser(Port, Rest, [foo___foo_nil___|Stack]);
pipedrv_deser(Port, <<?T_ATOM:8, Len:8, Rest/binary>>, Stack) ->
    <<A:Len/binary, Rest2/binary>> = Rest,
    pipedrv_deser(Port, Rest2, [list_to_atom(binary_to_list(A))|Stack]);
pipedrv_deser(Port, <<?T_PORT:8, P:32/unsigned, Rest/binary>>, Stack) ->
    %% The pipe driver tried sending us a port, but it cannot know what
    %% port ID was assigned to this port, so we'll assume it is Port.
    pipedrv_deser(Port, Rest, [Port|Stack]);
pipedrv_deser(Port, <<?T_INT:8, I:32/signed, Rest/binary>>, Stack) ->
    pipedrv_deser(Port, Rest, [I|Stack]);
pipedrv_deser(Port, <<?T_TUPLE:8, N:8, Rest/binary>>, Stack) ->
    {L, NewStack} = popN(N, Stack),
    pipedrv_deser(Port, Rest, [list_to_tuple(L)|NewStack]);
pipedrv_deser(Port, <<?T_LIST:8, N:32, Rest/binary>>, Stack) ->
    {L, NewStack} = popN(N, Stack),
    pipedrv_deser(Port, Rest, [L|NewStack]);
pipedrv_deser(Port, <<?T_BINARY:8, Len:32/signed, Rest/binary>>, Stack) ->
    <<Bin:Len/binary, Rest2/binary>> = Rest,
    pipedrv_deser(Port, Rest2, [Bin|Stack]);
pipedrv_deser(Port, <<?T_STRING:8, Len:32/signed, Rest/binary>>, Stack) ->
    <<Bin:Len/binary, Rest2/binary>> = Rest,
    pipedrv_deser(Port, Rest2, [binary_to_list(Bin)|Stack]);
pipedrv_deser(Port, X, Y) ->
    throw({bah, X, Y}).

popN(N, Stack) ->
    popN(N, Stack, []).
popN(0, Stack, Acc) ->
    {Acc, Stack};
popN(N, [foo___foo_nil___|T], Acc) ->
    %% This is the nonsense we put on the stack to represent NIL.  Ignore it.
    popN(N - 1, T, Acc);
popN(N, [H|T], Acc) ->
    popN(N - 1, T, [H|Acc]).


%%%
%%% Begin code included via <custom_erl> tags
%%%


make_vertex_array(L) ->
    make_vertex_array(L, []).
make_vertex_array([], Acc) ->
    L = length(Acc),
    if L > ?_MAX_POLYGON_VERTICES -> badarg;
       true                       -> {L, lists:reverse(Acc)}
    end;
make_vertex_array([{X, Y}|Vs], Acc) ->
    make_vertex_array(Vs, [<<X:32/signed-integer, Y:32/signed-integer>>|Acc]);
make_vertex_array([X, Y|Vs], Acc) when integer(X), integer(Y) ->
    make_vertex_array(Vs, [<<X:32/signed-integer, Y:32/signed-integer>>|Acc]).

make_style_array(L) ->
    [<<X:32/signed-integer>> || X <- L].
 

